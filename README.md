# 1. 자바스크립트와 변수
자바스크립트(JavaScript)는 객체(object) 기반의 스크립트 언어입니다.

HTML로는 웹의 내용을 작성하고, CSS로는 웹을 디자인하며, 자바스크립트로는 웹의 동작을 구현할 수 있습니다.

자바스크립트는 주로 웹 브라우저에서 사용되나, Node.js와 같은 프레임워크를 사용하면 서버 측 프로그래밍에서도 사용할 수 있습니다.

현재 컴퓨터나 스마트폰 등에 포함된 대부분의 웹 브라우저에는 자바스크립트 인터프리터가 내장되어 있습니다.

#### 예제
```
    <!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>JavaScript Intro</title>
        <script>
            document.write("<h2>이 내용은 문서에 출력합니다!!</h2>")
        </script>
    </head> 
    <body>
        <noscript>
            <p>이 웹 브라우저는 자바스크립트를 지원하지 않습니다!</p>
        </noscript>
    </body>
    </html>
```

## 자바스크립트(JavaScript)란?
자바스크립트(JavaScript)는 객체(object) 기반의 스크립트 언어입니다.

HTML로는 웹의 내용을 작성하고, CSS로는 웹을 디자인하며, 자바스크립트로는 웹의 동작을 구현할 수 있습니다.

자바스크립트는 주로 웹 브라우저에서 사용되나, Node.js와 같은 프레임워크를 사용하면 서버 측 프로그래밍에서도 사용할 수 있습니다.

현재 컴퓨터나 스마트폰 등에 포함된 대부분의 웹 브라우저에는 자바스크립트 인터프리터가 내장되어 있습니다.

### 자바스크립트의 역사
자바스크립트는 1995년에 넷스케이프(Netscape)의 브렌던 아이크(Brendan Eich)에 의해 만들어졌습니다.

처음에는 모카(Mocha)라는 이름으로 개발되었으나, 그 후에 라이브스크립트(LiveScript), 최종적으로는 자바스크립트(JavaScript)라는 이름으로 변경됩니다.

### 자바스크립트의 특징
자바스크립트가 가지고 있는 언어적 특징은 다음과 같습니다.
 
1. 자바스크립트는 객체 기반의 스크립트 언어입니다.
2. 자바스크립트는 동적이며, 타입을 명시할 필요가 없는 인터프리터 언어입니다.
3. 자바스크립트는 객체 지향형 프로그래밍과 함수형 프로그래밍을 모두 표현할 수 있습니다.

### 자바와 자바스크립트
자바와 자바스크립트는 그 이름만 놓고 보면 서로 관련이 있는 언어로 생각되기 쉽습니다.

하지만 두 언어는 서로 직접적인 관련은 없으며, 비슷한 점보다는 다른 점이 훨씬 많습니다.

문법상 비슷한 부분은 두 언어의 문법이 모두 C언어를 기반으로 만들어졌기 때문입니다.

|자바|자바스크립트|
|------|---|
|컴파일 언어|인터프리터 언어|
|타입 검사를 엄격하게 함.|타입을 명시하지 않음.|
|클래스(class) 기반의 객체 지향 언어|프로토타입(prototype) 기반의 객체 지향 언어|

### 자바스크립트 표준
1996년에 넷스케이프(Netscape)는 자바스크립트를 국제 표준안으로 만들기 위해 ECMA(European Computer Manufacturers Association)에 제출합니다.

그 결과 ECMA는 ECMAScript라는 새로운 표준을 제정하였고, 그 첫 번째 버전인 ECMA-262를 1997년에 공표합니다.

ECMAScript는 자바스크립트뿐만 아니라 마이크로소프트의 JScript나 어도비의 액션스크립트도 따르는 국제 표준이 됩니다.

현재 자바스크립트의 최신 표준은 2015년에 발표된 ECMAScript 6입니다.


### 자바스크립트 문법
프로그램(program)이란?
프로그램은 컴퓨터가 실행할 수 있는 명령(instruction)으로 이루어집니다.

컴퓨터 프로그래밍에서 컴퓨터가 실행할 수 있는 명령들을 실행문(statement)이라고 합니다.

즉, 프로그램이란 특정 결과를 얻기 위해서 컴퓨터에 의해 실행되는 실행문의 집합이라고 할 수 있습니다.

#### 자바스크립트 문법
자바스크립트의 실행문은 세미콜론(;)으로 구분됩니다.

예제
```
    var x = 10;
    var result = x + 3;
```


자바스크립트는 대소문자를 구분합니다.
자바스크립트에서 변수나 함수의 이름, 예약어 등을 작성하거나 사용할 때에는 대소문자를 정확히 구분해서 사용해야 합니다.
예제
```
    var javascript = 10; // 변수 javascript와 JavaScript는 서로 다른 두 개의 변수로 인식됨.

    var JavaScript = 20;

    Var Script = 30; // 변수의 선언은 var 키워드로만 할 수 있으면 Var는 동작하지 않음.
```

#### 리터럴(literal)
리터럴은 직접 표현되는 값 그 자체를 의미합니다.

다음 예제에서 등장하는 값들은 모두 리터럴입니다.
예제
```
    12            // 숫자 리터럴
    "JavaScript"  // 문자열 리터럴
    '안녕하세요'  // 문자열 리터럴
    true          // 불리언 리터럴
```

#### 식별자(identifier)
식별자는 변수나 함수의 이름을 작성할 때 사용하는 이름을 의미합니다.

자바스크립트에서 식별자는 영문자(대소문자), 숫자, 언더스코어(_) 또는 달러($)만을 사용할 수 있습니다.


#### 식별자 작성 방식
자바스크립트에서는 식별자를 작성할 때 다음과 같은 작성 방식을 사용할 수 있습니다.

1. Camel Case 방식
2. Underscore Case 방식

Camel Case 방식이란 식별자가 여러 단어로 이루어질 경우에 첫 번째 단어는 모두 소문자로 작성하고, 그다음 단어부터는 첫 문자만 대문자로 작성하는 방식입니다.

Underscore Case 방식은 식별자를 이루는 단어들을 소문자로만 작성하고, 그 단어들은 언더스코어(_)로 연결하는 방식입니다.

자바스크립트에서는 식별자를 작성할 때 관행적으로 Camel Case 방식을 많이 사용합니다.
따라서 코드의 가독성 및 통일성을 위해 Camel Case 방식만을 사용합니다.

예제
```
    var firstVar = 10;           // Camel Case 방식
    function my_first_func {     // Underscore Case 방식
        var firstLocalVar = 20;  // Camel Case 방식
    }
```

#### 키워드(keyword)
자바스크립트에서는 몇몇 단어들을 특별한 용도로 사용하기 위해 미리 예약하고 있습니다.

이렇게 미리 예약된 단어들을 키워드(keyword) 또는 예약어(reserved word)라고 합니다.

이러한 키워드들은 프로그램 내에서 식별자로 사용할 수 없습니다.

예제
```
    var firstVar = 10;      // var는 변수의 정의를 위해 예약된 키워드입니다.
    function myFirstFunc {  // function은 함수의 정의를 위해 예약된 키워드입니다.
        var secondVar = 20; // var는 변수의 정의를 위해 예약된 키워드입니다.
    }
```


#### 주석(comment)
주석(comment)이란 코드 내에 삽입된 일종의 설명문입니다.

주석은 작성자나 다른 개발자가 나중에 코드를 수정할 때 참고할 수 있으며, 웹 페이지 개발 시 디버깅에도 사용됩니다.

이러한 주석은 자바스크립트 코드의 어느 부분에라도 작성할 수 있으며, 웹 브라우저의 동작에는 전혀 영향을 미치지 않습니다.

자바스크립트 주석은 다음과 같은 두 가지 형식을 지원합니다.
문법
1. 한 줄 주석 : // 주석문
2. 여러 줄 주석 : /* 주석문 */

예제
```
    var x = 10;
    // var y = 20; 한 줄의 주석문 : 이 부분은 실행되지 않을 것입니다.
    /*
    x = x + y;
    여러 줄의 주석문 :
    이 부분 또한 실행되지 않을 것입니다.
    */
    document.getElementById("text").innerHTML = x;
```

여러 줄 주석일 경우 주석 내부에 또 다른 여러 줄 주석을 삽입할 수는 없습니다.
그러므로 자바스크립트에서 여러 줄 주석은 절대로 중첩해서 사용해서는 안 됩니다.


### 자바스크립트 출력
자바스크립트는 여러 방법을 통해 결과물을 HTML 페이지에 출력할 수 있습니다.

자바스크립트에서 사용할 수 있는 출력 방법은 다음과 같습니다.

1. window.alert() 메소드
2. HTML DOM 요소를 이용한 innerHTML 프로퍼티
3. document.write() 메소드
4. console.log() 메소드

#### window.alert() 메소드
자바스크립트에서 가장 간단하게 데이터를 출력할 수 있는 방법은 window.alert() 메소드를 이용하는 것입니다.

window.alert() 메소드는 브라우저와는 별도의 대화 상자를 띄워 사용자에게 데이터를 전달해 줍니다.

예제
```
    <script>
        function alertDialogBox() {
            alert("확인을 누를 때까지 다른 작업을 할 수 없어요!");
        }
    </script>
```


#### HTML DOM 요소를 이용한 innerHTML 프로퍼티
실제 자바스크립트 코드에서 출력을 위해 가장 많이 사용되는 방법은 HTML DOM 요소를 이용한 innerHTML 프로퍼티를 이용하는 방법입니다.

우선 document 객체의 getElementByID()나 getElementsByTagName() 등의 메소드를 사용하여 HTML 요소를 선택합니다.

그리고서 innerHTML 프로퍼티를 이용하면 선택된 HTML 요소의 내용(content)이나 속성(attribute)값 등을 손쉽게 변경할 수 있습니다.

예제
```
    <script>
        var str = document.getElementById("text");
        str.innerHTML = "이 문장으로 바뀌었습니다!";
    </script>
```

#### document.write() 메소드
document.write() 메소드는 웹 페이지가 로딩될 때 실행되면, 웹 페이지에 가장 먼저 데이터를 출력합니다.

따라서 document.write() 메소드는 대부분 테스트나 디버깅을 위해 사용됩니다.

예제
```
    <script>
        document.write("<h1>여기는 제목입니다.</h1>");
    </script>
```


#### console.log() 메소드
console.log() 메소드는 웹 브라우저의 콘솔을 통해 데이터를 출력해 줍니다.

대부분의 주요 웹 브라우저에서는 F12를 누른 후, 메뉴에서 콘솔을 클릭하면 콘솔 화면을 사용할 수 있습니다.

이러한 콘솔 화면을 통한 데이터의 출력은 좀 더 자세한 사항까지 출력되므로, 디버깅하는데 많은 도움을 줍니다.

예제
```
    <p>F12를 눌러서 콘솔 화면을 열면 결과를 확인할 수 있습니다.</p>
    <script>
        console.log(4 * 5);
    </script>
```



### 자바스크립트 적용
자바스크립트를 적용하는 방법
HTML 문서에 자바스크립트 코드를 적용하는 방법에는 다음과 같은 방법이 있습니다.

1. 내부 자바스크립트 코드로 적용
2. 외부 자바스크립트 파일로 적용

#### 내부 자바스크립트 코드
자바스크립트 코드는 <script>태그를 사용하여 HTML 문서 안에 삽입할 수 있습니다.

문법
```
    <script>
        document.getElementById("text").innerHTML = "여러분을 환영합니다!";
    </script>
```
 
이렇게 삽입된 자바스크립트 코드는 HTML 문서의 <head>태그나 <body>태그, 또는 양쪽 모두에 위치할 수 있습니다.

다음 예제는 HTML 문서의 <head>태그에 자바스크립트 코드를 삽입한 예제입니다.

예제
```
    <head>
        <meta charset="UTF-8">
        <title>JavaScript Apply</title>
        <script>
            function printDate() {
                document.getElementById("date").innerHTML = Date();
            }
        </script>
    </head>
```

다음 예제는 HTML 문서의 <body>태그에 자바스크립트 코드를 삽입한 예제입니다.

예제
```
    <body>
        <p>자바스크립트를 이용하면 현재 날짜와 시간 정보에도 손쉽게 접근할 수 있어요!</p>
        <button onclick="printDate()">현재 날짜와 시간 표시하기!</button>
        <p id="date"></p>
        <script>
            function printDate() {
                document.getElementById("date").innerHTML = Date();
            }
        </script>
    </body>
```

위의 두 예제에서 살펴볼 수 있듯이 자바스크립트 코드를 <head>태그에 삽입하나 <body>태그에 삽입하나 동작상의 차이는 없습니다.


#### 외부 자바스크립트 파일
자바스크립트 코드는 HTML 문서의 내부뿐만 아니라 외부 파일로 생성하여 삽입할 수도 있습니다.

외부에 작성된 자바스크립트 파일은 .js 확장자를 사용하여 저장합니다.

해당 자바스크립트 파일을 적용하고 싶은 모든 웹 페이지에 <script>태그를 사용해 외부 자바스크립트 파일을 포함하면 됩니다.

main_script.js
```
    function printDate() {
        document.getElementById("date").innerHTML = Date();
    }
```

예제
```
    <head>
        <meta charset="UTF-8">
        <title>JavaScript Apply</title>
        <script src="./js/main_script.js"></script>
    </head>
```

외부 자바스크립트 파일을 사용하면 웹의 내용을 담당하는 HTML 코드로부터 웹의 동작을 구현하는 자바스크립트 코드를 분리할 수 있습니다.

이렇게 하면 HTML 코드와 자바스크립트 코드를 각각 읽기도 편해지고, 유지 보수도 쉬워집니다.

또한, 외부 자바스크립트 파일은 웹 브라우저가 미리 읽어 올 수 있어 웹 페이지의 로딩 속도 또한 빨라집니다.







## 변수
### 변수의 선언과 초기화
변수(variable)란 데이터(data)를 저장할 수 있는 메모리 공간을 의미하며, 그 값이 변경될 수 있습니다.

자바스크립트에서는 var 키워드를 사용하여 변수를 선언합니다.

자바스크립트에서는 선언되지 않은 변수를 사용하려고 하거나 접근하려고 하면 오류가 발생합니다.

단, 선언되지 않은 변수를 초기화할 경우에는 자동으로 선언을 먼저 한 후 초기화를 진행합니다.

예제
```
    var month; // month라는 이름의 변수 선언
    date = 25; // date라는 이름의 변수를 묵시적으로 선언
```

선언된 변수는 나중에 초기화할 수도 있고, 선언과 동시에 초기화할 수도 있습니다.
예제

```
var month;     // 변수의 선언
var date = 25; // 변수의 선언과 동시에 초기화
month = 12;    // 변수의 초기화
```
 
쉼표(,) 연산자를 이용하여 여러 변수를 동시에 선언하거나 초기화할 수도 있습니다.

예제
```
    var month, date;             // 여러 변수를 한 번에 선언
    var hours = 7, minutes = 15; // 여러 변수를 선언과 동시에 초기화
    month = 10, date = 5;        // 여러 변수를 한 번에 초기화
```


### 변수의 타입과 초깃값
자바스크립트의 변수는 타입이 정해져 있지 않으며, 같은 변수에 다른 타입의 값을 다시 대입할 수도 있습니다.

이렇게 한 변수에 다른 타입의 값을 여러 번 대입할 수는 있지만, 한 번 선언된 변수를 재선언할 수는 없습니다.

예제
```
    var num = 10;        // 변수의 선언과 함께 초기화
    num = [10, 20, 30];  // 배열 대입
    var num;             // 이 재선언문은 무시됨.
```
배열(array)이란 여러 값들로 이루어진 하나의 집합을 의미합니다.


자바스크립트에서 선언만 되고 초기화하지 않은 변수는 undefined 값을 갖습니다.
예제
```
    var num;  // undefined
    num = 10; // 10
```


### 변수의 이름
자바스크립트에서 변수는 이름을 가지고 식별하므로, 변수의 이름은 식별자(identifier)입니다.
변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_) 또는 달러($)로만 구성됩니다.
또한, 숫자와의 구분을 빠르게 하려고 숫자로는 시작할 수 없습니다.
이러한 변수의 이름은 대소문자를 구분하며, 자바스크립트 언어에서 예약된 키워드는 이름으로 사용할 수 없습니다.


### 기본 타입
타입(data type)이란 프로그램에서 다룰 수 있는 값의 종류를 의미합니다.

자바스크립트에서는 여러 가지 형태의 타입을 미리 정의하여 제공하고 있으며, 이것을 기본 타입이라고 합니다.

자바스크립트의 기본 타입은 크게 원시 타입과 객체 타입으로 구분할 수 있습니다.

원시 타입(primitive type)은 다음과 같습니다.
1. 숫자(number)
2. 문자열(string)
3. 불리언(boolean)
4. 심볼(symbol) : ECMAScript 6부터 제공됨
5. undefined

객체 타입(object type)은 다음과 같습니다.
6. 객체(object)
예제
```
    var num = 10;          // 숫자
    var myName = "홍길동"; // 문자열
    var str;               // undefined
```

#### 숫자(number)
자바스크립트는 다른 언어와는 달리 정수와 실수를 따로 구분하지 않고, 모든 수를 실수 하나로만 표현합니다.
또한, 매우 큰 수나 매우 작은 수를 표현할 경우에는 e 표기법을 사용할 수 있습니다.
예제
```
    var firstNum = 10;     // 소수점을 사용하지 않은 표현
    var secondNum = 10.00; // 소수점을 사용한 표현
    var thirdNum = 10e6;   // 10000000
    var fourthNum = 10e-6; // 0.00001
```

#### 문자열(string)
자바스크립트에서 문자열은 큰따옴표("")나 작은따옴표('')로 둘러싸인 문자의 집합을 의미합니다.

큰따옴표는 작은따옴표로 둘러싸인 문자열에만 포함될 수 있으며, 작은따옴표는 큰따옴표로 둘러싸인 문자열에만 포함될 수 있습니다.

예제
```
    var firstStr = "이것도 문자열입니다.";      // 큰따옴표를 사용한 문자열
    var secondStr = '이것도 문자열입니다.';     // 작은따옴표를 사용한 문자열
    var thirdStr = "나의 이름은 '홍길동'이야."  // 작은따옴표는 큰따옴표로 둘러싸인 문자열에만 포함될 수 있음.

    var fourthStr = '나의 이름은 "홍길동"이야.' // 큰따옴표는 작은따옴표로 둘러싸인 문자열에만 포함될 수 있음.
```


자바스크립트에서는 숫자와 문자열을 더할 수도 있습니다.

이럴 경우에 자바스크립트는 숫자를 문자열로 자동 변환하여, 두 문자열을 연결하는 연산을 수행합니다.

예제
```
    var num = 10;
    var str = "JavaScript";
    document.getElementById("result").innerHTML = (num + str); // 10JavaScript
```


#### 불리언(boolean)
불리언 값은 참(true)과 거짓(false)을 표현합니다.

자바스크립트에서 불리언 값은 예약어인 true와 false를 사용하여 나타낼 수 있습니다.
예제
```
    var firstNum = 10;
    var secondNum = 11;
    document.getElementById("result").innerHTML = (firstNum == secondNum); // false
```

#### 심볼(symbol)
심볼 타입은 ECMAScript 6부터 새롭게 추가된 타입입니다.

심볼은 유일하고 변경할 수 없는 타입으로, 객체의 프로퍼티를 위한 식별자로 사용할 수 있습니다.

예제
```
    var sym = Symbol("javascript");  // symbol 타입
    var symObj = Object(sym);        // object 타입
```
심볼 타입은 익스플로러에서 지원하지 않습니다.


#### typeof 연산자
typeof 연산자는 피연산자의 타입을 반환하는 피연산자가 단 하나뿐인 연산자입니다.

예제
```
    typeof 10;        // number 타입
    typeof "문자열";  // string 타입
    typeof true;      // boolean 타입
    typeof undefined; // undefined 타입
    typeof null;      // object 타입
```


#### null과 undefined
자바스크립트에서 null이란 object 타입이며, 아직 '값'이 정해지지 않은 것을 의미합니다.

또한, undefined란 null과는 달리 '타입'이 정해지지 않은 것을 의미합니다.

따라서 자바스크립트에서 undefined는 초기화되지 않은 변수나 존재하지 않는 값에 접근할 때 반환됩니다.

예제
```
    var num;          // 초기화하지 않았으므로 undefined 값을 반환함.
    var str = null;   // object 타입의 null 값
    typeof secondNum; // 정의되지 않은 변수에 접근하면 undefined 값을 반환함.
```
null과 undefined는 동등 연산자(==)와 일치 연산자(===)로 비교할 때 그 결괏값이 다르므로 주의해야 합니다.

null과 undefined는 타입을 제외하면 같은 의미지만, 타입이 다르므로 일치하지는 않습니다.

예제
```
    null ==  undefined; // true
    null === undefined; // false
```



### 객체(object)
자바스크립트의 기본 타입은 객체(object)입니다.
객체(object)란 실생활에서 우리가 인식할 수 있는 사물로 이해할 수 있습니다.

객체는 여러 프로퍼티(property)나 메소드(method)를 같은 이름으로 묶어놓은 일종의 집합체입니다.

예제
```
    var dog = { name: "해피", age: 3 }; // 객체의 생성
    // 객체의 프로퍼티 참조
    document.getElementById("result").innerHTML =
        "강아지의 이름은 " + dog.name + "이고, 나이는 " + dog.age + "살 입니다.";
```        




### 타입 변환
#### 타입 변환(type conversion)
자바스크립트는 타입 검사가 매우 유연한 언어입니다.

자바스크립트의 변수는 타입이 정해져 있지 않으며, 같은 변수에 다른 타입의 값을 다시 대입할 수도 있습니다.

예제
```
    var num = 20; // Number 타입의 20
    num = "이십"; // String 타입의 "이십"
    var num;      // 한 변수에 여러 번 대입할 수는 있지만, 변수의 재선언은 할 수 없습니다. 재선언문은 무시됩니다.
```

#### 묵시적 타입 변환(implicit type conversion)
자바스크립트는 특정 타입의 값을 기대하는 곳에 다른 타입의 값이 오면, 자동으로 타입을 변환하여 사용합니다.

즉, 문자열 값이 오길 기대하는 곳에 숫자가 오더라도 자바스크립트는 알아서 숫자를 문자열로 변환하여 사용합니다.

예제
```
    10 + "문자열"; // 문자열 연결을 위해 숫자 10이 문자열로 변환됨.
    "3" * "5";     // 곱셈 연산을 위해 두 문자열이 모두 숫자로 변환됨.
    1 - "문자열";  // NaN
```

위의 세 번째 예제에서 뺄셈 연산을 위해 문자열이 숫자로 변환되어야 하나, 해당 문자열은 두 번째 예제의 문자열과는 달리 숫자로 변환될 수 없는 문자열입니다.

따라서 의미에 맞게 자동으로 타입을 변환할 수 없으므로, 자바스크립트는 NaN 값을 반환합니다.

NaN은 Not a Number의 축약형으로, 정의되지 않은 값이나 표현할 수 없는 값이라는 의미를 가집니다.
이러한 NaN은 Number 타입의 값으로 0을 0으로 나누거나, 숫자로 변환할 수 없는 피연산자로 산술 연산을 시도하는 경우에 반환되는 읽기 전용 값입니다.
명시적 타입 변환(explicit type conversion)
자바스크립트에서는 묵시적 타입 변환을 많이 사용하지만, 명시적으로 타입을 변환할 방법도 제공합니다.

명시적 타입 변환을 위해 자바스크립트가 제공하는 전역 함수는 다음과 같습니다.
1. Number()
2. String()
3. Boolean()
4. Object()
5. parseInt()
6. parseFloat()

예제
```
    Number("10"); // 숫자 10
    String(true); // 문자열 "true"
    Boolean(0);   // 불리언 false
    Object(3);    // new Number(3)와 동일한 결과로 숫자 3
```


#### 숫자를 문자열로 변환
숫자를 문자열로 변환하는 가장 간단한 방법은 String() 함수를 사용하는 것입니다.

또한, null과 undefined를 제외한 모든 타입의 값이 가지고 있는 toString() 메소드를 사용할 수도 있습니다.

숫자(Number) 객체는 숫자를 문자열로 변환하는 다음과 같은 메소드를 별도로 제공합니다.
1. toExponential()
2. toFixed()
3. toPrecision()

|메소드|설명|
|-----|---|
|toExponential()|정수 부분은 1자리, 소수 부분은 입력받은 수만큼 e 표기법을 사용하여 숫자를 문자열로 변환함.|
|toFixed()|소수 부분을 입력받은 수만큼 사용하여 숫자를 문자열로 변환함.|
|toPrecision()|입력받은 수만큼 유효 자릿수를 사용하여 숫자를 문자열로 변환함.|
 
메소드(method)란 객체의 프로퍼티 값으로 함수를 갖는 프로퍼티를 의미합니다.

메소드에 대한 더 자세한 사항은 자바스크립트 객체의 개념 수업에서 확인할 수 있습니다.

숫자 객체의 메소드에 대한 더 자세한 사항은 자바스크립트 Number 메소드 수업에서 확인할 수 있습니다.

#### 불리언 값을 문자열로 변환
불리언 값을 문자열로 변환하는 방법에는 String() 함수와 toString() 메소드를 사용하는 방법이 있습니다.

예제
```
    String(true);     // 문자열 "true"
    false.toString(); // 문자열 "false"
```

#### 날짜를 문자열이나 숫자로 변환
날짜를 문자열로 변환하는 방법에는 String() 함수와 toString() 메소드를 사용하는 방법이 있습니다.

자바스크립트에서 날짜(Date) 객체는 문자열과 숫자로 모두 변환할 수 있는 유일한 타입입니다.
 

날짜(Date) 객체는 날짜를 숫자로 변환하는 다음과 같은 메소드를 별도로 제공합니다.
1. getDate()
2. getDay()
3. getFullYear()
4. getMonth()
5. getTime()
6. getHours()
7. getMinutes()
8. getSeconds()
9. getMilliseconds()
 

|메소드|설명|
|------|------------|
|getDate()|날짜 중 일자를 숫자로 반환함. (1 ~ 31)|
|getDay()|날짜 중 요일을 숫자로 반환함. (일요일 : 0 ~ 토요일 : 6)|
|getFullYear()|날짜 중 연도를 4자리 숫자로 반환함. (yyyy년)|
|getMonth()|날짜 중 월을 숫자로 반환함. (1월 : 0 ~ 12월 : 11)|
|getTime()|1970년 1월 1일부터 현재까지의 시간을 밀리초(millisecond) 단위의 숫자로 반환함.|
|getHours()|시간 중 시를 숫자로 반환함. (0 ~ 23)|
|getMinutes()|시간 중 분을 숫자로 반환함. (0 ~ 59)|
|getSeconds()|시간 중 초를 숫자로 반환함. (0 ~ 59)|
|getMilliseconds()|시간 중 초를 밀리초(millisecond) 단위의 숫자로 반환함. (0 ~ 999)|
 

예제
```
    String(Date());        // Mon May 16 2016 19:35:25 GMT+0900
    Date().toString();     // Mon May 16 2016 19:35:25 GMT+0900
    var date = new Date(); // Date 객체 생성
    date.getFullYear();    // 2016
    date.getTime();        // 1463394925632 -> 1970년 1월 1일부터 현재까지의 시간을 밀리초 단위의 숫자로 반환함.
```

#### 문자열을 숫자로 변환
문자열을 숫자로 변환하는 가장 간단한 방법은 Number() 함수를 사용하는 것입니다.
자바스크립트는 문자열을 숫자로 변환해 주는 두 개의 전역 함수를 별도로 제공합니다.
1. parseInt()
2. parseFloat()

|함수|설명|
|------|------------|
|parseInt()|문자열을 파싱하여 특정 진법의 정수를 반환함.|
|parseFloat()|문자열을 파싱하여 부동 소수점 수를 반환함.|
 
이 두 전역 함수에 대한 더 자세한 사항은 자바스크립트 Number 메소드 수업에서 확인할 수 있습니다.


#### 불리언 값을 숫자로 변환
불리언 값을 숫자로 변환하는 방법에는 Number() 함수를 사용하는 방법이 있습니다.

예제
```
    Number(true);  // 숫자 1
    Number(false); // 숫자 0
```




---------------------------------------




# 02. 연산자
## 연산자(operator) 란?
자바스크립트는 여러 종류의 연산을 위한 다양한 연산자(operator)를 제공하고 있습니다.

## 산술 연산자
산술 연산자는 사칙연산을 다루는 가장 기본적이면서도 많이 사용하는 연산자입니다.

산술 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

| 산술 연산자 | 설명 |
|-------|------------|
| + |왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 더함.|
| - |왼쪽 피연산자의 값에서 오른쪽 피연산자의 값을 뺌.|
| * |왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 곱함.|
| / |왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눔.|
| % |왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 나머지를 반환함.|

예제
```
    var x = 10, y = 4;
    document.write(x + y + "<br>"); // 14
    document.write(x - y + "<br>"); // 6
    document.write(x * y + "<br>"); // 40
    document.write(x / y + "<br>"); // 2.5
    document.write(x % y);          // 2
```

### 자바스크립트 연산자의 우선순위표
자바스크립트에서 연산자의 우선순위와 결합 방향은 다음과 같습니다
|우선순위|연산자|설명|결합 방향|
|-----|-----|-------------|------------|
| 1 |	&#40;&#41; |	묶음(괄호)	| - |
| 2	| &#46;	| 멤버 접근	| 왼쪽에서 오른쪽으로 |
| 	| new |	인수 있는 객체 생성	| - |
| 3	|  &#40;&#41; |	함수 호출 | 왼쪽에서 오른쪽으로 |
|   | new |	인수 없는 객체 생성	| 오른쪽에서 왼쪽으로 |
| 4	| &#43;&#43; |	후위 증가 연산자	| - |
|   | &#45;&#45; |	후위 감소 연산자	| - |
| 5	| &#33;	| 논리 NOT 연산자 | 오른쪽에서 왼쪽으로 |
|   | &#126;	| 비트 NOT 연산자 | 오른쪽에서 왼쪽으로 |
|   | &#43;	| 양의 부호 (단항 연산자) | 오른쪽에서 왼쪽으로 |
| 	| &#45;	| 음의 부호 (단항 연산자) | 오른쪽에서 왼쪽으로 |
| 	| &#43;&#43; | 전위 증가 연산자	| 오른쪽에서 왼쪽으로 |
|	| &#45;&#45; | 전위 감소 연산자	| 오른쪽에서 왼쪽으로 |
| 	| typeof | 타입 반환 |	오른쪽에서 왼쪽으로 |
| 	| void | undefined 반환	| 오른쪽에서 왼쪽으로 |
| 	| delete | 프로퍼티의 제거 | 오른쪽에서 왼쪽으로 |
| 6	| &#42;&#42; | 거듭제곱 연산자| 오른쪽에서 왼쪽으로 |
| 	| &#42;	| 곱셈 연산자 | 왼쪽에서 오른쪽으로 |
| 	| &#47;	| 나눗셈 연산자	| 왼쪽에서 오른쪽으로 |
| 	| &#37;	| 나머지 연산자	| 왼쪽에서 오른쪽으로 |
| 7	| &#43;	| 덧셈 연산자 (이항 연산자)	| 왼쪽에서 오른쪽으로 |
| 	| &#45;	| 뺄셈 연산자 (이항 연산자)	| 왼쪽에서 오른쪽으로 |
| 8	| &#60;&#60; | 비트 왼쪽 시프트 연산자 | 왼쪽에서 오른쪽으로 |
| 	| &#62;&#62; | 부호 비트를 확장하면서 비트 오른쪽 시프트 | 왼쪽에서 오른쪽으로 |
| 	| &#62;&#62;&#62; |	부호 비트를 확장하지 않고 비트 오른쪽 시프트 | 왼쪽에서 오른쪽으로 |
| 9	| &#60;	| 관계 연산자(보다 작은) | 왼쪽에서 오른쪽으로 |
| 	| &#60;&#61; |	관계 연산자(보다 작거나 같은) |	왼쪽에서 오른쪽으로 |
| 	| &#62;	| 관계 연산자(보다 큰) | 왼쪽에서 오른쪽으로 |
| 	| &#62;&#61;|	관계 연산자(보다 크거나 같은) |	왼쪽에서 오른쪽으로 |
| 	| instanceof | 인스턴스 여부 판단 | 왼쪽에서 오른쪽으로 |
| 10 |	&#61;&#61; | 동등 연산자 |	왼쪽에서 오른쪽으로 |
|   | &#61;&#61;&#61; | 일치 연산자	| 왼쪽에서 오른쪽으로 |
| 	| &#33;&#61; |	부등 연산자	| 왼쪽에서 오른쪽으로 |
| 	| &#33;&#61;&#61; |	불일치 연산자 | 왼쪽에서 오른쪽으로 |
| 11 |	&#38; |	비트 AND 연산자	| 왼쪽에서 오른쪽으로 |
| 12 |	&#94; | 비트 XOR 연산자	| 왼쪽에서 오른쪽으로 |
| 13 |	&#124; | 비트 OR 연산자 | 왼쪽에서 오른쪽으로 |
| 14 |	&#38;&#38;	| 논리 AND 연산자 |	왼쪽에서 오른쪽으로 |
| 15 |	&#124;&#124;	| 논리 OR 연산자 |	왼쪽에서 오른쪽으로 |
| 16 |	&#63; &#58;	| 삼항 연산자 |	오른쪽에서 왼쪽으로 |
| 17 |	&#124;&#61;	| 대입 연산자 (&#61;, &#43;&#61;, &#45;&#61;, &#42;&#61;, &#47;&#61;, &#37;&#61;, &#60;&#60;&#61;, &#62;&#62;&#61;, &#62;&#62;&#62;&#61;, &#38;&#61;, &#94;&#61;, &#124;&#61;)	| 오른쪽에서 왼쪽으로 |
| 18 |	&#46;&#46;&#46;	| 전개	| - |
| 19 |	&#44;	| 쉼표 연산자   | 왼쪽에서 오른쪽으로 |



## 대입 연산자
### 대입 연산자(assignment operator)
대입 연산자는 변수에 값을 대입할 때 사용하는 이항 연산자이며, 피연산자들의 결합 방향은 오른쪽에서 왼쪽입니다.

또한, 앞서 살펴본 산술 연산자와 결합한 다양한 복합 대입 연산자가 존재합니다.

| 대입 연산자 |	설명 |
|----|----------|
| =	왼쪽 피연산자에 오른쪽 피연산자의 값을 대입함. |
| += |	왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 더한 후, 그 결괏값을 왼쪽 피연산자에 대입함. |
| -= | 왼쪽 피연산자의 값에서 오른쪽 피연산자의 값을 뺀 후, 그 결괏값을 왼쪽 피연산자에 대입함. |
| *= |	왼쪽 피연산자의 값에 오른쪽 피연산자의 값을 곱한 후, 그 결괏값을 왼쪽 피연산자에 대입함. |
| /= |	왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 결괏값을 왼쪽 피연산자에 대입함. |
| %= | 왼쪽 피연산자의 값을 오른쪽 피연산자의 값으로 나눈 후, 그 나머지를 왼쪽 피연산자에 대입함. |



## 증감 연산자
### 증감 연산자(increment and decrement operator)
증감 연산자는 피연산자를 1씩 증가 혹은 감소시킬 때 사용하는 연산자입니다.
이 연산자는 피연산자가 단 하나뿐인 단항 연산자입니다.

증감 연산자는 해당 연산자가 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서 및 결과가 달라집니다.

| 증감 연산자 |	설명 |
|-----|--------------|
| ++x |	먼저 피연산자의 값을 1 증가시킨 후에 해당 연산을 진행함. |
| x++ |	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 증가시킴. |
| --x |	먼저 피연산자의 값을 1 감소시킨 후에 해당 연산을 진행함. |
| x-- |	먼저 해당 연산을 수행하고 나서, 피연산자의 값을 1 감소시킴. |
 

예제
```
    var x = 10, y = 10;
    document.write((++x - 3) + "<br>"); // x의 값을 우선 1 증가시킨 후에 3을 뺌.
    document.write(x + "<br>");         // 11
    document.write((y++ - 3) + "<br>"); // 먼저 y에서 3을 뺀 후에 y의 값을 1 증가시킴.
    document.write(y);                  // 11
```
### 증감 연산자의 연산 순서
증감 연산자는 피연산자의 어느 쪽에 위치하는가에 따라 연산의 순서가 달라집니다.
다음 예제는 증감 연산자의 연산 순서를 살펴보기 위한 예제입니다.
예제
```
    var x = 10;            
    var y = x-- + 5 + --x;
    // x = 8, y = 23
```
### y = x-- + 5 + --x

① x-- : 첫 번째 감소 연산자(decrement operator)는 피연산자의 뒤쪽에 위치하므로, 덧셈 연산이 먼저 수행됩니다.
② x-- + 5: 덧셈 연산이 수행된 후에 감소 연산이 수행됩니다. (x의 값 : 9)
③ --x : 두 번째 감소 연산자는 피연산자의 앞쪽에 위치하므로, 덧셈 연산보다 먼저 수행됩니다. (x의 값 : 8)
④ x-- + 5 + --x : 감소 연산이 수행된 후에 덧셈 연산이 수행됩니다.
⑤ y = x-- + 5 + --x : 마지막으로 변수 y에 결괏값의 대입 연산이 수행됩니다. (y의 값 : 23)





## 비교 연산자
### 비교 연산자(comparison operator)
비교 연산자는 피연산자 사이의 상대적인 크기를 판단하여, 참(true)과 거짓(false)을 반환합니다.

비교 연산자는 모두 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

| 비교 연산자 |	설명 |
|---|-----------------|
| == |	왼쪽 피연산자와 오른쪽 피연산자의 값이 같으면 참을 반환함. |
| === |	왼쪽 피연산자와 오른쪽 피연산자의 값이 같고, 같은 타입이면 참을 반환함. |
| != |	왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않으면 참을 반환함. |
| !== |	왼쪽 피연산자와 오른쪽 피연산자의 값이 같지 않거나, 타입이 다르면 참을 반환함. |
| >	| 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크면 참을 반환함. |
| >= | 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 크거나 같으면 참을 반환함. |
| <	| 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작으면 참을 반환함. |
| <= | 왼쪽 피연산자의 값이 오른쪽 피연산자의 값보다 작거나 같으면 참을 반환함. |
 
※ 자바스크립트에서 비교 연산자는 피연산자의 타입에 따라 두 가지 기준으로 비교를 진행합니다.

1. 피연산자가 둘 다 숫자면, 해당 숫자를 서로 비교합니다.
2. 피연산자가 둘 다 문자열이면, 문자열의 첫 번째 문자부터 알파벳 순서대로 비교합니다.

예제
```
    var x = 3, y = 5;
    var a = "abc", b = "bcd";
    document.write((x > y) + "<br>");  // y의 값이 x의 값보다 크므로 false
    document.write((a <= b) + "<br>"); // 알파벳 순서상 'a'가 'b'보다 먼저 나오므로 'a'가 'b'보다 작음.
    document.write(x < a);             // x의 값은 숫자이고 a의 값은 문자열이므로 비교할 수 없음.
```
위의 세 번째 연산에서 변수 x의 값은 숫자이고, 변수 a의 값은 문자열입니다.

비교 연산자 < 는 x의 값이 a의 값보다 작을 때만 참을 반환하고, 나머지 경우에는 전부 거짓을 반환하는 연산자입니다.

따라서 타입이 서로 달라 비교할 수 없는 경우에는 참의 조건을 만족하게 하지 못하므로, 언제나 거짓(false)만을 반환하게 됩니다.



### 동등 연산자와 일치 연산자
동등 연산자(==, equal)와 일치 연산자(===, strict equal)는 모두 두 개의 피연산자가 서로 같은지를 비교해 줍니다.

두 연산자 모두 피연산자의 타입을 가리지는 않지만, 그 같음을 정의하는 기준이 조금 다릅니다.

동등 연산자(==)는 두 피연산자의 값이 서로 같으면 참(true)을 반환합니다.

이때 두 피연산자의 타입이 서로 다르면, 비교를 위해 강제로 타입을 같게 변환합니다.

하지만 일치 연산자(===)는 타입의 변환 없이 두 피연산자의 값이 같고, 타입도 같아야만 참(true)을 반환합니다.

예제
```
    var x = 3, y = '3', z = 3;
    document.write((x == y) + "<br>");  // x와 y의 타입이 서로 다르므로 타입을 서로 같게 한 후 비교를 하므로 true
    document.write((x === y) + "<br>"); // x와 y의 타입이 서로 다르므로 false
    document.write(x === z);            // x와 z은 값과 타입이 모두 같으므로 true
```    

부등 연산자(!=)와 불일치 연산자(!==)는 각각 동등 연산자와 일치 연산자의 비교와 정확히 반대로 동작합니다.

예제
```
    var x = 10, y = 10, z = 10;
    x = x - 5;
    y -= 5; // y = y - 5 와 같은 표현임.
    z =- 5; // z = -5 와 같은 표현임.
```




## 논리 연산자
### 논리 연산자(logical operator)
논리 연산자는 주어진 논리식을 판단하여, 참(true)과 거짓(false)을 반환합니다.

&& 연산자와 || 연산자는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

! 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.

| 논리 연산자 |	설명 |
|----|-------------------|
| &#38;&#38; | 논리식이 모두 참이면 참을 반환함. (논리 AND 연산) |
| &#124;&#124; | 논리식 중에서 하나라도 참이면 참을 반환함. (논리 OR 연산) |
| &#33;	 | 논리식의 결과가 참이면 거짓을, 거짓이면 참을 반환함. (논리 NOT 연산) |
 

다음은 논리 연산자의 모든 동작의 결과를 보여주는 진리표(truth table)입니다.

| A	| B	| A &#38;&#38; B |	A &#124;&#124; B | &#33;A |
|----|----|----|----|----|
| true	| true	| true	| true	| false |
| true	| false	| false	| true	| false |
| false	| true	| false	| true	| true |
| false	| false	| false	| false	| true |
 

예제
```
    var x = true, y = false;
    document.write((x && y) + "<br>"); // false (논리 AND 연산)
    document.write((x || y) + "<br>"); // true  (논리 OR  연산)
    document.write(!x);                // false (논리 NOT 연산)
```



## 비트 연산자
### 비트 연산자(bitwise operator)
비트 연산자는 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 수행합니다.
또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용합니다.

| 비트 연산자 |	설명 |
|----|---------------|
| &#38;	| 대응되는 비트가 모두 1이면 1을 반환함. (비트 AND 연산) |
| &#124;	| 대응되는 비트 중에서 하나라도 1이면 1을 반환함. (비트 OR 연산) |
| &#94;	| 대응되는 비트가 서로 다르면 1을 반환함. (비트 XOR 연산) |
| &#126;	| 비트를 1이면 0으로, 0이면 1로 반전시킴. (비트 NOT 연산) |
| &#60;&#60; | 지정한 수만큼 비트를 전부 왼쪽으로 이동시킴. (left shift 연산) |
| &#62;&#62; | 부호를 유지하면서 지정한 수만큼 비트를 전부 오른쪽으로 이동시킴. (right shift 연산) |
| &#62;&#62;&#62; |	지정한 수만큼 비트를 전부 오른쪽으로 이동시키며, 새로운 비트는 전부 0이 됨. |
 
다음 그림은 비트 AND 연산자(&)의 동작을 나타냅니다.
이처럼 비트 AND 연산자는 대응되는 두 비트가 모두 1일 때만 1을 반환하며, 다른 경우는 모두 0을 반환합니다.

#### 비트 AND 연산

| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
|---|---|---|---|---|---|---|---|
| &#38; | &#38; | &#38; | &#38; | &#38; | &#38; | &#38; | &#38; |
| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1 |
-------------------------------------------------
| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |
|---|---|---|---|---|---|---|---|

 

다음 그림은 비트 OR 연산자(|)의 동작을 나타냅니다.
이처럼 비트 OR 연산자는 대응되는 두 비트 중 하나라도 1이면 1을 반환하며, 두 비트가 모두 0일 때만 0을 반환합니다.

#### 비트 OR 연산
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
|---|---|---|---|---|---|---|---|
| &#124; | &#124; | &#124; | &#124; | &#124; | &#124; | &#124; | &#124; |
| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1 |
-------------------------------------------------
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 |
|---|---|---|---|---|---|---|---| 

다음 그림은 비트 XOR 연산자(^)의 동작을 나타냅니다.
이처럼 비트 XOR 연산자는 대응되는 두 비트가 서로 다르면 1을 반환하고, 서로 같으면 0을 반환합니다.

#### 비트 XOR 연산

| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
|---|---|---|---|---|---|---|---|
| &#94; | &#94; | &#94; | &#94; | &#94; | &#94; | &#94; | &#94; |
| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1 |
-------------------------------------------------
| 0 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |
|---|---|---|---|---|---|---|---|
 

다음 그림은 비트 NOT 연산자(~)의 동작을 나타냅니다.
이처럼 비트 NOT 연산자는 해당 비트가 1이면 0을 반환하고, 0이면 1을 반환합니다.
#### 비트 NOT 연산
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
|---|---|---|---|---|---|---|---|
| &#126; | &#126; | &#126; | &#126; | &#126; | &#126; | &#126; | &#126; |
-------------------------------------------------
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
|---|---|---|---|---|---|---|---|
 

다음 예제는 시프트 연산자(<<, >>)와 비트 NOT 연산자(~)의 예제입니다.

예제
```
    var x = 15, y = 8, z = 15;
    document.write((x << 1) + "<br>"); // 곱하기 2와 같으므로 15 * 2 = 30
    document.write((y >> 1) + "<br>"); // 나누기 2와 같으므로 8 / 2 = 4
    document.write(~z);                // 1의 보수와 같으므로 -(15+1) = -16
```

위의 예제에서 첫 번째 연산은 비트를 전부 왼쪽으로 1비트씩 이동시키는 연산입니다.
따라서 그 결괏값은 처음 값에 2를 곱한 것과 같게 됩니다.
반대로 두 번째 연산은 비트를 전부 오른쪽으로 1비트씩 이동시키는 연산입니다.
따라서 그 결괏값은 처음 값에 2를 나눈 것과 같게 됩니다.




## 기타 연산자
### 문자열 결합 연산자
자바스크립트에서 덧셈(+) 연산자는 피연산자의 타입에 따라 두 가지 다른 연산을 수행합니다.
1. 피연산자가 둘 다 숫자이면, 산술 연산인 덧셈을 수행합니다.
2. 피연산자가 하나라도 문자열이면, 문자열 결합을 수행합니다.

예제
```
    var x = 3 + 4;                   // 피연산자가 둘 다 숫자이면 덧셈 연산을 수행함.
    var y = "좋은 " + "하루 되세요!" // 피연산자가 둘 다 문자열이면 문자열 결합 연산을 수행함.
    var z = 12 + "월"                // 피연산자가 하나라도 문자열이면 문자열 결합 연산을 수행함.
```
피연산자가 하나는 문자열이고 다른 하나는 문자열이 아닐 때, 자바스크립트는 문자열이 아닌 피연산자를 자동으로 문자열로 변환한 후 문자열 결합을 수행합니다.



### 삼항 연산자(ternary operator)
삼항 연산자는 유일하게 피연산자를 세 개나 가지는 조건 연산자입니다.

삼항 연산자의 문법은 다음과 같습니다.
문법
표현식 ? 반환값1 : 반환값2

물음표(?) 앞의 표현식에 따라 결괏값이 참이면 반환값1을 반환하고, 결괏값이 거짓이면 반환값2를 반환합니다.

예제
```
    var x = 3, y = 5;
    var result = (x > y) ? x : y   // x가 더 크면 x를, 그렇지 않으면 y를 반환함.
    document.write("둘 중에 더 큰 수는 " + result + "입니다.");
```

삼항 연산자는 짧은 if / else 문 대신 사용할 수 있으며, 코드를 간결하게 만들어 줍니다.



### 쉼표 연산자
쉼표 연산자를 for 문에서 사용하면, 루프마다 여러 변수를 동시에 갱신할 수 있습니다.

예제
```
    // 루프마다 i의 값은 1씩 증가하고, 동시에 j의 값은 1씩 감소함.
    for (var i = 0, j = 9; i <= j; i++, j--) {
        document.write("i의 값은 " + i + "이고, j의 값은 " + j + "입니다.<br>");
    }
```

### delete 연산자
delete 연산자는 피연산자인 객체, 객체의 프로퍼티(property) 또는 배열의 요소(element) 등을 삭제해 줍니다.

피연산자가 성공적으로 삭제되었을 경우에는 참(true)을 반환하고, 삭제하지 못했을 경우에는 거짓(false)을 반환합니다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.

예제
```
    var arr = [1, 2, 3];          // 배열 생성
    delete arr[2];                // 배열의 원소 중 인덱스가 2인 요소를 삭제함.
    document.write(arr + "<br>"); // [1, 2, ]
    // 배열에 빈자리가 생긴 것으로 undefined 값으로 직접 설정된 것은 아님.
    document.write(arr[2] + "<br>");
    // 배열의 요소를 삭제하는 것이지 배열의 길이까지 줄이는 것은 아님.
    document.write(arr.length);
```



### typeof 연산자
typeof 연산자는 피연산자의 타입을 반환합니다.
이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.

자바스크립트에서 많이 사용하는 값과 그 값에 대한 typeof 연산자의 결괏값은 다음과 같습니다.

| 값 | typeof 연산자의 결괏값 |
|----|-------------------|
| 숫자, NaN	| "number" |
| 문자열 | "string" |
| true, false | "boolean" |
| null | "object" |
| undefined | "undefined" |
| 함수 | "function" |
| 함수가 아닌 객체 | "object" |
 

예제
```
    typeof "문자열"   // string
    typeof 10         // number
    typeof NaN        // number
    typeof false      // boolean
    typeof undefined  // undefined
    typeof new Date() // object
    typeof null       // object
```


### instanceof 연산자
instanceof 연산자는 피연산자인 객체가 특정 객체의 인스턴스인지 아닌지를 확인해 줍니다.

피연산자가 특정 객체의 인스턴스이면 참(true)을 반환하고, 특정 객체의 인스턴스가 아니면 거짓(false)을 반환합니다.

이 연산자는 두 개의 피연산자를 가지는 이항 연산자이며, 피연산자들의 결합 방향은 왼쪽에서 오른쪽입니다.

예제
```
    var str = new String("이것은 문자열입니다.");
    str instanceof Object;  // true
    str instanceof String;  // true
    str instanceof Array;   // false
    str instanceof Number;  // false
    str instanceof Boolean; // false
```

인스턴스와 객체에 대한 더 자세한 사항은 자바스크립트 객체의 개념 수업에서 확인할 수 있습니다.



### void 연산자
void 연산자는 피연산자로 어떤 타입의 값이 오던지 상관없이 언제나 undefined 값만을 반환합니다.

이 연산자는 피연산자가 단 하나뿐인 단항 연산자이며, 피연산자의 결합 방향은 오른쪽에서 왼쪽입니다.

예제
```
    <a href="javascript:void(0)">이 링크는 동작하지 않습니다.</a>
    <a href="javascript:void(document.body.style.backgroundColor='yellow')">
        이 링크도 동작하지 않지만, HTML 문서의 배경색을 바꿔줍니다.
    </a>
```
위의 예제처럼 void 연산자는 정의되지 않은 원시 타입의 값을 얻기 위해 void(0)과 같은 형태로 종종 사용됩니다.


<br><br><br><br>

# 03. 제어문(control flow statements)
프로그램의 순차적인 흐름을 제어해야 할 때 사용하는 실행문을 제어문이라고 합니다.
이러한 제어문에는 조건문, 반복문, 기타 제어문 등이 포함됩니다.
<br><br>
## 조건문(conditional statements)
조건문이란 프로그램 내에서 주어진 표현식의 결과에 따라 별도의 명령을 수행하도록 제어하는 실행문입니다.

조건문 중에서 가장 기본이 되는 실행문은 if 문입니다.

자바스크립트에서 사용할 수 있는 조건문의 형태는 다음과 같습니다.
1. if 문
2. if / else 문
3. if / else if / else 문
4. switch 문

### if 문
if 문은 표현식의 결과가 참(true)이면 주어진 실행문을 실행하며, 거짓(false)이면 아무것도 실행하지 않습니다.
문법
```
    if (조건식) {
        조건식의 결과가 참일 때 실행하고자 하는 실행문;
    }
```

예제
```
    var x = 10, y = 20;
    if (x == y) {  //동등 연산자는 "="이 아니라 "=="이다.
        document.write("x와 y는 같습니다.");
    }
    if (x < y) {
        document.write("x가 y보다 작습니다.");
    }

    if (x > y) // 실행될 실행문이 한 줄뿐이라면 중괄호({})를 생략할 수 있음.
        document.write("x가 y보다 큽니다.");
```

<br>

### if~ else~ 문
if 문과 같이 사용할 수 있는 else 문은 if 문의 표현식 결과가 거짓(false)일 때 주어진 실행문을 실행합니다.

문법
```
    if (조건식) {
        조건식의 결과가 참일 때 실행하고자 하는 실행문;
    } else {
        조건식의 결과가 거짓일 때 실행하고자 하는 실행문;
    }
```

<br>

### if~ else if~ else~ 문
else if 문은 if 문처럼 표현식을 설정할 수 있으므로, 중첩된 if 문을 좀 더 간결하게 표현할 수 있습니다.

하나의 조건문 안에서 if 문과 else 문은 단 한 번만 사용될 수 있습니다.

하지만 else if 문은 여러 번 사용되어 다양한 조건을 설정할 수 있습니다.

문법
```
    if (조건식1) {
        조건식1의 결과가 참일 때 실행하고자 하는 실행문;
    } else if (조건식2) {
        조건식2의 결과가 참일 때 실행하고자 하는 실행문;
    } else {
        조건식1의 결과도 거짓이고, 조건식2의 결과도 거짓일 때 실행하고자 하는 실행문;
    }
```
else if 문을 사용하면 앞선 예제를 더욱 간결하게 표현할 수 있습니다.

예제
```
    var x = 10, y = 20;
    if (x == y) {
        document.write("x와 y는 같습니다.");
    } else if (x < y) {
        document.write("x가 y보다 작습니다.");
    } else { // x > y인 경우
        document.write("x가 y보다 큽니다.");
    }
```

<br>

### 삼항 연산자에 의한 조건문
자바스크립트에서는 간단한 if / else 문을 삼항 연산자를 이용하여 간단히 표현할 수 있습니다.

문법
```
    표현식 ? 반환값1 : 반환값2

```

예제
```
    var a = 20;
    var b = 30; 
    var max = (a > b) ? a : b;   //큰 값 구하기
```

<br>

### switch 문
switch 문은 if / else 문과 마찬가지로 주어진 조건 값에 따라 프로그램이 다른 명령을 수행하도록 하는 조건문입니다.

이러한 switch 문은 if / else 문보다 가독성 측면에서 더 좋습니다.

문법
```
    switch (조건 값) {
        case 값1:
            조건 값이 값1일 때 실행하고자 하는 실행문;
            break;
        case 값2:
            조건 값이 값2일 때 실행하고자 하는 실행문;
            break;
        ...
        default:
            조건 값이 어떠한 case 절에도 해당하지 않을 때 실행하고자 하는 실행문;
            break;
    }
```

예제
```
    var x = 10;
    switch (typeof x) {
        case "number":
            document.write("변수 x의 타입은 숫자입니다.");
            break;
        case "string":
            document.write("변수 x의 타입은 문자열입니다.");
            break;
        case "object":
            document.write("변수 x의 타입은 객체입니다.");
            break;
        default:
            document.write("변수 x의 타입을 잘 모르겠네요...");
            break;
    }
```

예제
```
    var day = new Date().getDay(); // 오늘의 요일을 반환함. (일요일: 0 ~ 토요일: 6)
    switch (day) {
        case 1: // 월요일인 경우
        case 2: // 화요일인 경우
        case 3: // 수요일인 경우
        case 4: // 목요일인 경우
        default: // 0부터 6까지의 값이 아닌 경우
            document.write("아직도 주말은 멀었네요... 힘내자구요!!");
            break;
        case 5: // 금요일인 경우
            document.write("오늘은 불금이네요!!");
            break;
        case 6: // 토요일인 경우
        case 0: // 일요일인 경우
            document.write("즐거운 주말에도 열심히 공부하는 당신~ 최고에요!!");
            break;
    }
```

<br><br><br>

## 반복문(iteration statements)
반복문이란 프로그램 내에서 똑같은 명령을 일정 횟수만큼 반복하여 수행하도록 제어하는 실행문입니다.

프로그램이 처리하는 대부분의 코드는 반복적인 형태가 많으므로, 가장 많이 사용되는 실행문 중 하나입니다.

자바스크립트에서 사용할 수 있는 반복문의 형태는 다음과 같습니다.
1. while 문
2. do / while 문
3. for 문
4. for / in 문
5. for / of 문

<br><br>

### while 문
while 문은 특정 조건을 만족할 때까지 계속해서 주어진 실행문을 반복 실행합니다.

문법
```
    while (조건식) {
        조건식의 결과가 참인 동안 반복적으로 실행하고자 하는 실행문;
    }
```

while 문은 우선 표현식이 참(true)인지를 판단하여 참이면 내부의 실행문을 실행합니다.
내부의 실행문을 전부 실행하고 나면, 다시 표현식으로 돌아와 또 한 번 표현식이 참인지를 판단하게 됩니다.
이렇게 표현식의 검사를 통해 반복해서 실행되는 반복문을 루프(loop)라고 합니다.

예제
```
    var i = 1;
    while (i < 10) { // 변수 i가 10보다 작을 때만 while 문을 반복함.
        document.write(i + "<br>");
        i++; // 반복할 때마다 변수 i를 1씩 증가시켜 변수 i가 10보다 커지면 반복문을 종료함.
    }
```

while 문 내부에 표현식의 결과를 변경하는 실행문이 존재하지 않을 경우 프로그램은 루프를 영원히 반복하게 됩니다.

이것을 무한 루프(infinite loop)에 빠졌다고 하며, 무한 루프에 빠진 프로그램은 영원히 종료되지 않습니다.

무한 루프는 특별히 의도한 경우가 아니라면 반드시 피해야 하는 상황입니다.

따라서, while 문을 작성할 때는 표현식의 결과가 어느 순간에는 거짓(false)을 갖도록 표현식를 변경하는 실행문을 반드시 포함해야 합니다.

※ while 문에서 실행될 실행문이 한 줄 뿐이라면 중괄호({})를 생략할 수 있습니다

<br><br>

### do / while 문
while 문은 루프에 진입하기 전에 먼저 표현식부터 검사합니다.
하지만 do / while 문은 먼저 루프를 한 번 실행한 후에 표현식을 검사합니다.
즉, do / while 문은 표현식의 결과와 상관없이 무조건 한 번은 루프를 실행합니다.

문법
```
    do {
        표현식의 결과가 참인 동안 반복적으로 실행하고자 하는 실행문;
    } while (표현식);
```

예제
```
    var i = 1, j = 1;
    while (i > 3) { // 변수 i의 초깃값은 1이기 때문에 이 while 문은 한 번도 실행되지 않음.
        document.write("i : " + (i++) + "<br>");
    }
    do { // 변수 j의 초깃값은 1이기 때문에 이 do / while 문은 단 한 번만 실행됨.
        document.write("j : " + (j++) + "<br>");
    } while (j > 3);
```

<br><br>

### for 문
for 문은 while 문과는 달리 자체적으로 초기식, 표현식, 증감식을 모두 포함하고 있는 반복문입니다.

따라서 while 문보다는 좀 더 간결하게 반복문을 표현할 수 있습니다.

문법
```
    for (초기식; 표현식; 증감식) {
        표현식의 결과가 참인 동안 반복적으로 실행하고자 하는 실행문;
    }
```

for 문을 구성하는 초기식, 표현식, 증감식은 각각 생략될 수 있습니다.
또한, 쉼표 연산자(,)를 사용하면 여러 개의 초기식이나 증감식을 동시에 사용할 수도 있습니다.

for 문을 사용하면 앞선 예제의 while 문을 더욱 더 간결하게 표현할 수 있습니다.
예제
```
    for (var i = 1; i < 10; i++) {
        document.write(i + "<br>");
    }
```
for 문에서 실행될 실행문이 한 줄 뿐이라면 중괄호({})를 생략할 수 있습니다

<br><br>

### for / in 문
for / in 문은 일반적인 for 문과는 전혀 다른 형태의 반복문입니다.

for / in 문은 해당 객체의 모든 열거할 수 있는 프로퍼티(enumerable properties)를 순회할 수 있도록 해줍니다.

※ 열거할 수 있는 프로퍼티란 내부적으로 enumerable 플래그가 true로 설정된 프로퍼티를 의미합니다.
이러한 프로퍼티들은 for / in 문으로 접근할 수 있게 됩니다.

이 반복문은 루프마다 객체의 열거할 수 있는 프로퍼티의 이름을 지정된 변수에 대입합니다.

이렇게 대입받은 변수를 이용하면 루프 안에서 객체의 열거할 수 있는 프로퍼티에 순차적으로 접근할 수 있습니다.

문법
```
    for (변수 in 객체) {
        객체의 모든 열거할 수 있는 프로퍼티의 개수만큼 반복적으로 실행하고자 하는 실행문;
    }
```
 

다음 예제는 for / in 문을 사용하여 배열의 요소에 접근하는 예제입니다.
예제
```
    var arr = [3, 4, 5];
    for (var i = 0; i < arr.length; i++) { // 배열 arr의 모든 요소의 인덱스(index)를 출력함.
        document.write(i + " ");
    }
    for (var i in arr) { // 위와 같은 동작을 하는 for / in 문
        document.write(i + " ");
    }
```

다음 예제는 for / in 문을 사용하여 객체의 프로퍼티에 접근하는 예제입니다.
예제
```
    var obj = { name : "이순신", age : 20 };
    for (var i in obj) {
        document.write(i + "<br>");
    }
```

<br><br>

### for / of 문
for / of 문은 반복할 수 있는 객체(iterable objects)를 순회할 수 있도록 해주는 반복문입니다.

자바스크립트에서 반복할 수 있는 객체에는 Array, Map, Set, arguments 객체 등이 있습니다.

이 반복문은 루프마다 객체의 열거할 수 있는 프로퍼티의 값을 지정된 변수에 대입합니다.

문법
```
    for (변수 of 객체) {
        객체의 모든 열거할 수 있는 프로퍼티의 개수만큼 반복적으로 실행하고자 하는 실행문;
    }
```

다음 예제는 for / of 문을 사용하여 배열의 요소에 접근하는 예제입니다.
예제
```
    var arr = [3, 4, 5];
    for (var i = 0; i < arr.length; i++) { // 배열 arr의 모든 요소의 인덱스(index)를 출력함.
        document.write(arr[i] + " ");
    }
    for (var value of arr) { // 위와 같은 동작을 하는 for / of 문
        document.write(value + " ");
    }
```
※ for / of 문은 익스플로러에서 지원하지 않습니다.

다음 예제는 for / of 문을 사용하여 Set 객체의 프로퍼티에 접근하는 예제입니다.
예제
```
    var arr = new Set([1, 1, 2, 2, 3, 3]);
    for (var value of arr) {
        document.write(value + " ");
    }
```

## 기타 제어문
### 루프의 제어
일반적으로 표현식의 검사를 통해 루프로 진입하면, 다음 표현식을 검사하기 전까지 루프 안에 있는 모든 실행문을 실행합니다.

하지만 continue 문과 break 문은 이러한 일반적인 루프의 흐름을 사용자가 직접 제어할 수 있게 해줍니다.

label 문을 사용하면 continue 문과 break 문의 동작이 프로그램의 흐름을 특정 영역으로 이동시킬 수 있습니다.

<br><br>

### label 문
label 문은 프로그램 내의 특정 영역을 식별할 수 있도록 해주는 식별자입니다.

label 문을 사용하면 continue 문과 break 문의 동작이 프로그램의 흐름을 특정 영역으로 이동시킬 수 있습니다.

문법
``` 
   label:
        식별하고자 하는 특정 영역
```

다음 예제에서 라벨인 arrIndex는 그 이후에 나오는 for 문 전체를 가리키는 식별자로 사용되고 있습니다.
예제
```
    arrIndex:
    for (var i in arr) {
        document.write(i);
    }
```
<br><br>

### continue 문
continue 문은 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고, 바로 다음 표현식의 판단으로 넘어가게 합니다.

보통 반복문 내에서 특정 조건에 대한 처리를 제외하고자 할 때 자주 사용됩니다.

자바스크립트에서 continue 문은 다음과 같이 두 가지 형태로 사용할 수 있습니다.
문법
1. continue;
2. continue 라벨이름;

다음 예제는 1부터 100까지의 정수 중에서 3의 배수를 제외하고 출력하는 예제입니다.
예제
```
    var exceptNum = 3;
    for (var i = 0; i <= 100; i++) {
        if (i % exceptNum == 0) // exceptNum의 배수는 출력하지 않음.
            continue;
        document.write(i + " ");
    }
```

다음 예제는 라벨을 이용하여 구구단의 값이 홀수인 경우에만 출력하는 예제입니다.
예제
```
    gugudan:
    for (var i = 2; i <= 9; i++) {
        dan:
        for (var j = 1; j <= 9; j++) {
            if ((i*j) % 2 == 0)
                continue dan;
            document.write(i + " * " + j + " = " + (i*j) + "<br>");
        }
    }
```

<br><br>

### break 문
break 문은 루프 내에서 사용하여 해당 반복문을 완전히 종료시키고, 반복문 바로 다음에 위치한 실행문으로 프로그램의 흐름을 이동시킵니다.

즉, 루프 내에서 표현식의 판단 결과에 상관없이 반복문을 완전히 빠져나가고 싶을 때 사용합니다.

문법
1. break;
2. break 라벨이름;

다음 예제는 배열에서 특정값을 가지고 있는 인덱스를 출력하는 예제입니다.
예제
```
    var lectures = ["html", "css", "자바스크립트", "php"];
    var topic = "자바스크립트";
    for (var i = 0; i < lectures.length; i++) {
        if (lectures[i] == topic) {
            document.write(topic + " 과목은 " + (i + 1) + "번째 과목입니다.");
            break; // 원하는 값을 찾은 후에는 더 이상 for 문을 반복하지 않고 빠져나감.
        }
    }
```

다음 예제는 라벨을 이용하여 구구단을 3단까지만 출력하는 예제입니다.
예제
gugudan:
for (var i = 2; i <= 9; i++) {
    dan:
    for (var j = 1; j <= 9; j++) {
        if (i > 3)
            break gugudan;
        document.write(i + " * " + j + " = " + (i*j) + "<br>");
    }
}


<br><br><br><br>


# 04. 배열과 객체
## 배열(Array)
### 배열(array)이란?
자바스크립트에서 배열(array)은 이름과 인덱스로 참조되는 정렬된 값의 집합으로 정의됩니다.

배열을 구성하는 각각의 값을 배열 요소(element)라고 하며, 배열에서의 위치를 가리키는 숫자를 인덱스(index)라고 합니다.

자바스크립트에서 배열의 특징은 다음과 같습니다.
1. 배열 요소의 타입이 고정되어 있지 않으므로, 같은 배열에 있는 배열 요소끼리의 타입이 서로 다를 수도 있습니다.
2. 배열 요소의 인덱스가 연속적이지 않아도 되며, 따라서 특정 배열 요소가 비어 있을 수도 있습니다.
3. 자바스크립트에서 배열은 Array 객체로 다뤄집니다.

<br><br>

### 배열의 생성
문법
1. var arr = [배열요소1, 배열요소2,...];          // 배열 리터럴을 이용하는 방법
2. var arr = Array(배열요소1, 배열요소2,...);     // Array 객체의 생성자를 이용하는 방법
3. var arr = new Array(배열요소1, 배열요소2,...); // new 연산자를 이용한 Array 객체 생성 방법

위의 세 가지 방법은 모두 같은 결과의 배열을 만들어 줍니다.

배열 리터럴은 대괄호([]) 안에 배열 요소를 쉼표로 구분하여 나열하는 방법으로 생성합니다.
예제
```
    var arrLit = [1, true, "JavaScript"];             // 배열 리터럴을 이용하는 방법
    var arrObj = Array(1, true, "JavaScript");        // Array 객체의 생성자를 이용하는 방법
    var arrNewObj = new Array(1, true, "JavaScript"); // new 연산자를 이용한 Array 객체 생성 방법
    document.write(arrLit + "<br>");                  // 1,true,JavaScript
    document.write(arrObj + "<br>");                  // 1,true,JavaScript 
    document.write(arrNewObj);                        // 1,true,JavaScript
```

<br><br>

### 배열의 참조
자바스크립트에서 배열의 각 요소를 참조하고 싶을 때는 [] 연산자를 사용합니다.

문법
```
    배열이름[인덱스]
```

자바스크립트에서는 배열 요소의 개수를 배열의 길이라고 합니다.
이러한 배열의 길이는 length 프로퍼티에 자동으로 갱신됩니다.

자바스크립트에서 인덱스는 언제나 0부터 시작합니다.
또한, 인덱스에는 음이 아닌 정수를 반환하는 임의의 표현식도 사용할 수 있습니다.
이러한 인덱스에는 232보다 작은 양수만을 사용할 수 있습니다.

다음 예제는 배열을 생성하고, 생성된 배열에 요소를 추가하고 삭제하는 예제입니다.
예제
```
    var arr = ["JavaScript"]; // 요소가 하나뿐인 배열을 생성함.
    var element = arr[0];     // 배열의 첫 번째 요소를 읽어서 대입함.
    arr[1] = 10;      // 배열의 두 번째 요소에 숫자 10을 대입함. 배열의 길이는 1에서 2로 늘어남.
    arr[2] = element; // 배열의 세 번째 요소에 변수 element의 값을 대입함. 배열의 길이는 2에서 3으로 늘어남.
    document.write("배열 arr의 요소에는 [" + arr + "]가 있습니다.<br>"); // 배열의 요소를 모두 출력함.
    document.write("배열 arr의 길이는 " + arr.length + "입니다.<br>");   // 배열의 길이를 출력함.
    delete arr[2];    // 배열의 세 번째 요소를 삭제함. 하지만 배열의 길이는 변하지 않음.
    document.write("배열 arr의 요소에는 [" + arr + "]가 있습니다.<br>"); // 배열의 요소를 모두 출력함.
    document.write("배열 arr의 길이는 " + arr.length + "입니다.");       // 배열의 길이를 출력함.
```

위의 예제에서 세 번째 실행문은 배열의 현재 길이보다 더 큰 인덱스에 요소를 저장하려고 합니다.

자바스크립트에서는 이렇게 배열의 길이를 넘는 인덱스에 요소를 저장하는 것을 허용합니다.

이때 배열의 길이는 자동으로 해당 인덱스까지 늘어나게 됩니다.

<br><br>

### 배열 요소의 추가
자바스크립트에서 배열에 새로운 배열 요소를 추가하는 방법은 다음과 같습니다.
문법
1. arr.push(추가할 요소);         // push() 메소드를 이용하는 방법
2. arr[arr.length] = 추가할 요소; // length 프로퍼티를 이용하는 방법
3. arr[특정인덱스] = 추가할 요소; // 특정 인덱스를 지정하여 추가하는 방법

push() 메소드와 length 프로퍼티를 이용한 방법은 모두 배열의 제일 끝에 새로운 요소를 추가합니다.

예제
```
    var arr = [1, true, "Java"];
    arr.push("Script");           // push() 메소드를 이용하는 방법
    document.write(arr + "<br>"); // 1,true,Java,Script
    arr[arr.length] = 100;        // length 프로퍼티를 이용하는 방법
    document.write(arr + "<br>"); // 1,true,Java,Script,100
    arr[10] = "자바스크립트";     // 특정 인덱스를 지정하여 추가하는 방법
    document.write(arr + "<br>"); // 1,true,Java,Script,100,,,,,,자바스크립트
    document.write(arr[7]);       // undefined
```

위의 예제에서 배열 arr의 길이는 최종적으로 11이 됩니다.

이때 배열 요소가 존재하는 인덱스는 0, 1, 2, 3, 4, 10뿐이며, 나머지 인덱스에는 배열 요소가 존재하지 않습니다.

이렇게 인덱스에 대응하는 배열 요소가 없는 부분을 배열의 홀(hole)이라고 합니다.

자바스크립트에서는 이러한 배열의 홀(hole)을 undefined 값을 가지는 요소처럼 취급합니다.

따라서 위의 예제에서처럼 배열의 홀을 참조하게 되면 undefined 값을 반환하게 됩니다.

<br><br>

### 배열의 순회(iteration)
배열의 모든 요소에 차례대로 접근하고 싶을 때는 for 문과 같은 반복문을 사용하여 접근할 수 있습니다.
예제
```
    var arr = [1, true, "JavaScript"];
    var result = "<table><tr>";
    for (var idx in arr) {
        result += "<td>" + arr[idx] + "</td>";
    }
    result += "</tr></table>";
    document.write(result);
```

<br><br>

### Array 객체
자바스크립트에서 배열(array)은 정렬된 값들의 집합으로 정의되며, Array 객체로 다뤄집니다.

또한, 자바스크립트는 사용자가 배열과 관련된 작업을 손쉽게 할 수 있도록 다양한 메소드도 제공하고 있습니다.

다음 예제는 배열과 각 배열 요소의 typeof 연산 결과를 보여주는 예제입니다.
예제
```
    var arr = new Array(10, "문자열", false);
    document.write((typeof arr) + "<br>");    // object
    document.write((typeof arr[0]) + "<br>"); // number
    document.write((typeof arr[1]) + "<br>"); // string
    document.write(typeof arr[2]);            // boolean
```

<br><br>

### 자바스크립트에서 배열 여부 확인
자바스크립트에서는 배열이라는 타입(type)을 별도로 제공하지 않습니다.

자바스크립트 배열은 객체(object) 타입이 되며, typeof 연산자를 사용하면 'object'를 반환합니다.

예제
```    
    var arr = [1, true, "JavaScript"]; // 배열 생성
    document.write(typeof arr);        // object
```

따라서 자바스크립트에서는 해당 변수가 배열인지 여부를 확인할 수 있도록 다음과 같은 방법들을 제공하고 있습니다.
1. Array.isArray() 메소드
2. instanceof 연산자
3. constructor 프로퍼티

ECMAScript 5부터는 Array 클래스에 isArray()라는 배열 여부를 확인할 수 있는 메소드를 추가하였습니다.
예제
``` 
    document.write(Array.isArray(arr));      // true
    document.write(Array.isArray("문자열")); // false
```

하지만, 구형 버전의 브라우저는 ECMAScript 5를 지원하지 않으므로, Array.isArray() 메소드가 정상적으로 동작하지 않을 수도 있습니다.

따라서 이때는 instanceof 연산자를 사용하여 해당 변수가 Array 객체인지를 판단하여 배열 여부를 확인할 수 있습니다.

예제
```    
    document.write(arr instanceof Array); // true
    document.write(123 instanceof Array); // false
```

또한, Array 객체의 constructor 프로퍼티를 사용하여 배열 여부를 확인할 수도 있습니다.

자바스크립트 배열에 대해 constructor 프로퍼티는 다음과 같은 값을 반환합니다.

문법
```
    function Array() {[native code]}
```

따라서 다음 예제와 같이 toString() 메소드와 indexOf() 메소드를 함께 사용하면 해당 변수의 배열 여부를 확인할 수 있습니다.
예제
```
    function isArray(a) {
        return a.constructor.toString().indexOf("Array") > -1;
    }
    var arr = [1, true, "JavaScript"];          // 배열 생성
    document.write(arr.constructor);            // constructor 프로퍼티의 값 출력
    document.write(arr.constructor.toString()); // function Array() {[native code]}
    document.write(arr.constructor.toString().indexOf("Array")); // 10
    document.write(isArray(arr))                // true
```
위 예제 ②번 라인에서는 toString() 메소드를 사용하여 constructor 프로퍼티의 값을 문자열로 변환합니다.

그리고 ③번 라인에서는 indexOf() 메소드를 사용하여 해당 문자열에서 "Array"라는 부분 문자열이 시작하는 인덱스를 구하고 있습니다.

indexOf() 메소드는 인수로 전달받은 문자열을 해당 문자열에서 찾지 못하면, 언제나 -1을 반환합니다.

따라서 만약 변수 arr가 배열이라면 "Array"라는 부분 문자열을 언제나 포함하고 있을 것이므로, ①번 라인의 결과는 언제나 true를 반환하게 됩니다.


<br><br><br>


## 객체(Object)
### 객체(object)란?
객체(object)란 실생활에서 우리가 인식할 수 있는 사물로 이해할 수 있습니다.

<br><br>

### 객체의 예
객체(object) - 고양이

#### 속성(property)
- cat.name = "나비"
- cat.family = "코리안 숏 헤어"
- cat.age = 0.1
- cat.weight = 300

위 설명에서 name, family, age, weight 등 을 cat이 가진 속성이라 함.

#### 메소드(method)
- cat.mew()
- cat.eat()
- cat.sleep()
- cat.play()

위 설명에서 mew(), eat(), sleep(), play() 등 은 cat의 행위인 메소드라고 함.

<br><br>

### 사용자 정의 객체
사용자가 필요에 따라 정의하는 객체

<br>

#### 객체의 생성

1. var 키워드에 의한 객체 정의
2. 생성자 함수 Object()를 사용하는 방식
3. 상속에 의한 객체 생성
4. 사용자 정의 생성자 함수(Constructor)에 의한 객체 생성

<br>

#### 방법1. var 키워드에 의한 객체 정의
문법
```
    var 객체명 = { 속성명1:"문자열값", 속성명2:숫자값, 속성명3:논리값,
        메소드명:function([매개변수1], [매개변수2]....) { 
            메소드실행구문;
            [this.속성명1;]
            [return 반환값;]
        }
    }
```

예제
```
    var obj1 = { name:"kim", kor:90, eng:80, mat:100, tot:function() {
            return this.kor+this.eng+this.mat;
        } 
    };
    document.write(obj1.name+"님의 총점은 "+obj1.tot()+"점 입니다.<br>");
```

<br>

#### 방법2. 생성자 함수 Object()를 사용하는 방식
문법
```
    var 객체명 = new Object();
    객체명.속성명1 = "문자열값";
    객체명.속성명2 = 숫자값;
    객체명.속성명3 = 논리값;
    객체명.메소드명 = function([매개변수1], [매개변수2]....){
        메소드실행구문;
        [this.속성명1;]
        [return 반환값;]
    };
```

예제
```
    var obj2 = new Object();
    obj2.name = "park";
    obj2.kor = 90;
    obj2.eng = 60;
    obj2.mat = 40;
    obj2.tot = function(){
        return this.kor+this.eng+this.mat;
    };
    document.write(obj2.name+"님의 총점은 "+obj2.tot()+"점 입니다.<br>");
```

<br>

#### 방법3. 상속에 의한 객체 생성
문법
```
    var 부모객체명 = Object.create(자식객체명); 
    자식객체명.속성명 = 값;
```    
예제
```
    var child = Object.create(obj2);  //obj2를 parent(부모)이며, child는 자식임
    child.name = "lee";
    document.write(child.name+"님의 총점은 "+child.tot()+"점 입니다.<br>");
```

<br>

#### 방법4. 사용자 정의 생성자 함수에 의한 객체 생성    
문법
```
    function 생성자함수명([매개변수1], [매개변수2]....){
        this.속성명1 = 매개변수1;
        this.속성명2 = 매개변수2;
        ....
        this.메소드명 = function 메소드함수(){
            메소드실행구문;
            [this.속성명1;]
            [return 반환값;]
        }
    }
    var 객체명 = new 생성자함수명([값1], [값2]....);
```

<br><br>

### 객체의 참조(값 가져오기와 넣기 그리고 실행)
객체명.속성명 또는 객체명["속성명"]
객체명.메소드명([값1], [값2]....)

예제
```
    document.write(obj1.name+"님의 총점은 "+obj1.tot()+"점 입니다.<br>");
    document.write(obj1.["name"]+"님의 총점은 "+obj1.tot()+"점 입니다.<br>");
```


## 데이터형 객체

### Number 객체
```javascript
Number.isFinite(Infinity)  // false
Number.isFinite(NaN)       // false
Number.isFinite('Hello')   // false
 
Number.isFinite(0)         // true
Number.isFinite(2e64)      // true
Number.isFinite(null)      // false. isFinite(null) => true

Number.isInteger(123)   //true
Number.isInteger(-123)  //true
Number.isInteger(5-2)   //true
Number.isInteger(0)     //true
Number.isInteger(0.5)   //false
Number.isInteger('123') //false
Number.isInteger(false) //false
Number.isInteger(Infinity)  //false
Number.isInteger(-Infinity) //false
Number.isInteger(0 / 0) //false

Number.isNaN(NaN)       // true
Number.isNaN(undefined) // false. undefined → NaN. isNaN(undefined) → true.
Number.isNaN({})        // false. {} → NaN.        isNaN({}) → true.
Number.isNaN('blabla')  // false. 'blabla' → NaN.  isNaN('blabla') → true.
 
Number.isNaN(true)      // false
Number.isNaN(null)      // false
Number.isNaN(37)        // false
Number.isNaN('37');     // false
Number.isNaN('37.37');  // false
Number.isNaN('');       // false
Number.isNaN(' ');      // false
Number.isNaN(new Date())             // false
Number.isNaN(new Date().toString())  // false. String → NaN. isNaN(String) → true.

Number.isSafeInteger(123)   //true
Number.isSafeInteger(-123)  //true
Number.isSafeInteger(5-2)   //true
Number.isSafeInteger(0)     //true
Number.isSafeInteger(1000000000000000)  // true
Number.isSafeInteger(10000000000000001) // false
Number.isSafeInteger(0.5)   //false
Number.isSafeInteger('123') //false
Number.isSafeInteger(Infinity)  //false
Number.isSafeInteger(-Infinity) //false
Number.isSafeInteger(0 / 0) //false

var numObj = 77.1234;
 
numObj.toExponential();  // logs 7.71234e+1
numObj.toExponential(4); // logs 7.7123e+1
numObj.toExponential(2); // logs 7.71e+1
77.1234.toExponential(); // logs 7.71234e+1
 
77.toExponential())      // SyntaxError: Invalid or unexpected token
77 .toExponential();     // logs 7.7e+1

77.toString(); // SyntaxError: Invalid or unexpected token
1.23.toString (); // '1.23'
(77).toString(); // '77'
77 .toString(); // '77'

var numObj = 12345.6789;

// 소숫점 이하 반올림
numObj.toFixed();   // '12346'
// 소숫점 이하 1자리수 유효, 나머지 반올림
numObj.toFixed(1);  // '12345.7'
// 소숫점 이하 2자리수 유효, 나머지 반올림
numObj.toFixed(2);  // '12345.68'

var n = 123.112
 
n.toPrecision(3)  // "123"
n.toPrecision(4) // "123.1"
n.toPrecision(5) // "123.11"

var count = 10;
count.toString();   // '10'
(17).toString();    // '17'
17 .toString();     // '17'
(17.2).toString();  // '17.2'
 
var x = 16;
x.toString(2);       // '10000'
x.toString(8);       // '20'
x.toString(16);      // '10'
 
(254).toString(16);  // 'fe'
(-10).toString(2);   // '-1010'
(-0xff).toString(2); // '-11111111

var x = 0xAB; // 16진법으로 표현된 10진수 171
var y = 29; // 10진법으로 표현된 10진수 29
 
x + y; // 두 수 모두 10진법으로 자동으로 변환되어 계산됨. -> 200

var num = 256;
 
num.toString(2); // 2진법으로 변환 : 100000000
num.toString(8); // 8진법으로 변환 : 400
num.toString(10); // 10진법으로 변환 : 256
num.toString(16); // 16진법으로 변환 : 100
 
// 2진수로 변환한 결괏값을 문자열로 반환함.
num.toString(2); // 100000000
// 문자열을 숫자로 나눴기 때문에 자동으로 10진수로 변환되어 산술 연산된 결괏값
(num.toString(2) / 2); // 50000000

var numObj = new Number(10);
typeof numObj; // object
 
var num = numObj.valueOf();
num;           // 10
typeof num;    // number
```

#### Number 관련 속성
| 속성 | 설명 |
|-----------------|----------------------------------------|
| MAX_VALUE | 자바스크립트에서 숫자 형태의 저장 가능한 가장 큰 값 반환 |
| MIN_VALUE | 자바스크립트에서 숫자 형태의 저장 가능한 가장 작은 값 반환 |
| POSITIVE_INFINITY | 자바스크립트 양의 무한대를 반환 |
| NEGATIVE_INFINITY | 자바스크립트 음의 무한대를 반환 |
| NaN | 자바스크립트 숫자가 아님을 의미하는 "Not a Number"를 반환 |

#### Number 관련 메소드
| 메소드 | 설명 |
|-----------------|----------------------------------------|
| 객체.toString(숫자 또는 표현식) | 숫자를 해당 형식의 문자열로 반환  |
| 객체.toExpotential(숫자) | 유효자릿수의 소수점 이하 부분을 지정한 숫자 만큼 표시  |
| Number(숫자형문자열 또는 숫자형문자열을 갖고 있는 변수명) | 해당 문자열을 숫자로 반환 |
| parseInt(숫자형문자열 또는 숫자형문자열을 갖고 있는 변수명) | 해당 문자열을 정수로 반환 |
| parseFloat(숫자형문자열 또는 숫자형문자열을 갖고 있는 변수명) | 해당 문자열을 실수로 반환 |
| isNaN(값 또는 계산식) | 해당 값이 NaN이면, true, 아니면 false 반환 |
| isFinite(값 또는 계산식) | 해당 값이 Finite이면, true, 아니면 false 반환 |
| isInteger(값 또는 계산식) | 해당 값이 정수이면, true, 아니면 false 반환 |


### Math 객체
```javascript
Math.abs(-1);       // 1
Math.abs('-1');     // 1
Math.abs('');       // 0
Math.abs([]);       // 0
Math.abs(null);     // 0
Math.abs(undefined);// NaN

Math.round(1.4);  // 1
Math.round(1.6);  // 2
Math.round(-1.4); // -1
Math.round(-1.6); // -2
Math.round(1);    // 1
Math.round();     // NaN

Math.ceil(1.4);  // 2
Math.ceil(1.6);  // 2
Math.ceil(-1.4); // -1
Math.ceil(-1.6); // -1
Math.ceil(1);    // 1
Math.ceil();     // NaN

Math.floor(1.9);  // 1
Math.floor(9.1);  // 9
Math.floor(-1.9); // -2
Math.floor(-9.1); // -10
Math.floor(1);    // 1
Math.floor();     // NaN

Math.sqrt(9);  // 3
Math.sqrt(-9); // NaN
Math.sqrt(2);  // 1.414213562373095
Math.sqrt(1);  // 1
Math.sqrt(0);  // 0
Math.sqrt();   // NaN

const random = Math.floor((Math.random() * 10) + 1);
console.log(random); // 1 ~ 10까지의 정수

Math.pow(2, 8);  // 256
Math.pow(2, -1); // 0.5

Math.max(1, 2, 3); // 3
 
// 배열 요소 중에서 최대값 취득
// max()  인수로 배열을 받을 수 없으니, 배열을 인수로 받는 apply를 사용
const arr = [1, 2, 3];
const max = Math.max.apply(null, arr); // 3
// ES6 문법
Math.max(...arr); // 3
[...rest] = [1,2,4]; // rest = [1,2,4]
Math.max(...rest); //4

Math.min(1, 2, 3); // 1
 
// 배열 요소 중에서 최소값 취득
const arr = [1, 2, 3];
const min = Math.min.apply(null, arr); // 1
// ES6 문법
Math.min(...arr); // 1
```

#### Math 관련 속성
| 속성 | 설명 |
|-----------------|----------------------------------------|
| Math.E | 오일러의 수(Euler's constant) 값	: 2.718 |
| Math.LN2 | 2의 자연로그 값 : 0.693 |
| Math.LN10 | 10의 자연로그 값 : 2.303 |
| Math.LOG2E | 오일러 수(e)의 밑 값이 2인 로그 값 : 1.443 |
| Math.LOG10E	| 오일러 수(e)의 밑 값이 10인 로그 값 : 0.434 |
| Math.PI | 원의 원주율 값 : 3.14159 |
| Math.SQRT1_2 | 2의 제곱근의 역수 값 : 0.707 |
| Math.SQRT2 | 2의 제곱근 값 : 1.414 |


#### Math 관련 메소드
| 메소드 | 설명 |
|-----------------|----------------------------------------|
| Math.min(x, y, ...) | 인수로 전달받은 값 중에서 가장 작은 수를 반환 |
| Math.max(x, y, ...) | 인수로 전달받은 값 중에서 가장 큰 수를 반환 |
| Math.random() | 0보다 크거나 같고 1보다 작은 랜덤 숫자(random number)를 반환 |
| Math.round(x) | x를 소수점 첫 번째 자리에서 반올림하여 그 결과를 반환 |
| Math.floor(x)	| x와 같거나 작은 수 중에서 가장 큰 정수를 반환 |
| Math.ceil(x) | x와 같거나 큰 수 중에서 가장 작은 정수를 반환 |
| Math.abs(x) | x의 절댓값을 반환 |
| Math.cbrt(x) | x의 세제곱근을 반환 |
| Math.sqrt(x) | x의 제곱근을 반환 |
| Math.clz32(x) | x을 32비트 이진수로 변환한 후, 0이 아닌 비트의 개수를 반환 |
| Math.exp(x) | ex(지수:Expotential) 의 값을 반환 |
| Math.expm1(x) | 1 - ex 의 값을 반환 |
| Math.fround(x) | x와 가장 근접한 32비트 부동 소수점 수(single precision float)를 반환 |
| Math.hypot(x, y, ...) | 인수로 전달받은 값들을 각각 제곱한 후 더한 총합의 제곱근을 반환 |
| Math.imul(x, y) | 인수로 전달받은 두 값의 32비트 곱셈의 결과 반환 |
| Math.log(x) | x의 자연로그 값을 반환 |
| Math.log1p(x) | ln(1 + x)의 값을 반환 |
| Math.log10(x) | x의 10을 밑으로 가지는 로그 값을 반환 |
| Math.log2(x) | x의 2를 밑으로 가지는 로그 값을 반환 |
| Math.pow(x, y) | x의 y승을 반환 |
| Math.sign(x) | x의 부호 값을 반환 |
| Math.trunc(x) | x의 모든 소수 부분을 삭제하고 정수 부분만을 반환 |
| Math.sin(x) | x는 각도로서 해당 sin 삼각 함수 결과값 반환 |
| Math.cos(x) | x는 각도로서 해당 cos 삼각 함수 결과값 반환 |
| Math.tan(x) | x는 각도로서 해당 tan 삼각 함수 결과값 반환 |
| Math.asin(x) | x는 각도로서 해당 asin 삼각 함수 결과값 반환 |
| Math.acos(x) | x는 각도로서 해당 acos 삼각 함수 결과값 반환 |
| Math.atan(x) | x는 각도로서 해당 atan 삼각 함수 결과값 반환 |
| Math.asinh(x) | x는 각도로서 해당 asinh 삼각 함수 결과값 반환 |
| Math.acosh(x) | x는 각도로서 해당 acosh 삼각 함수 결과값 반환 |
| Math.atanh(x) | x는 각도로서 해당 atanh 삼각 함수 결과값 반환 |
| Math.atan2(x) | x는 각도로서 해당 atanh2 삼각 함수 결과값 반환 |	

### Date 객체
```javascript
const date1 = new Date();
console.log(date1);  //현재 시간 출력

let date2 = new Date('May 16, 2019 17:22:10');
console.log(date2); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시)
 
date2 = new Date('2019/05/16/17:22:10');
console.log(date2); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시)


let date3 = new Date(2019, 4);
console.log(date3); // Wed May 01 2019 00:00:00 GMT+0900 (한국 표준시)
 
// 월을 나타내는 4는 5월을 의미한다.
// 2019/5/16/17:24:30:00
date3 = new Date(2019, 4, 16, 17, 24, 30, 0);
console.log(date3); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)
 
// new Date(dateString) 형식이 가독성이 훨씬 좋다.
date3 = new Date('2019/5/16/17:24:30:10');
console.log(date3); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)

let date4 = Date();
console.log(typeof date4); // string 
console.log(date4); // "Thu May 16 2019 17:33:03 GMT+0900 (한국 표준시)"
 
let date5 = new Date();
console.log(typeof date5); // object
console.log(date5); // Thu May 16 2019 17:33:03 GMT+0900 (한국 표준시) { }
 
// Object라 메소드를 사용할수 있다.
console.log(date5.getDay()); // 6

let d = Date.parse('Jan 2, 1970 00:00:00 UTC'); // UTC
console.log(d); // 86400000
 
d = Date.parse('Jan 2, 1970 09:00:00'); // KST
console.log(d); // 86400000
 
d = Date.parse('1970/01/02/09:00:00'); // KST
console.log(d); // 86400000

d = Date.UTC(1970, 0, 2);
console.log(d); // 86400000
 
d = Date.UTC('1970/1/2');
console.log(d); // NaN

const today = new Date();
 
// 월을 지정
today.setMonth(0); // 1월
 
console.log(today); // Wed Jan 16 2019 17:45:20 GMT+0900 (한국 표준시)
console.log(today.getMonth()); // 0
 
// 월/일을 지정
today.setMonth(11, 1); // 12월 1일
 
console.log(today); // Sun Dec 01 2019 17:45:20 GMT+0900 (한국 표준시)
console.log(today.getMonth()); // 1

const today2 = new Date();
 
// 날짜 지정
today2.setDate(1);
 
console.log(today2); // Wed May 01 2019 17:47:01 GMT+0900 (한국 표준시)
console.log(today2.getDate());  // 1

const today = new Date();
 
// 시간 지정
today3.setHours(7);
 
console.log(today3); // Thu May 16 2019 07:49:06 GMT+0900 (한국 표준시)
console.log(today3.getHours()); // 7
 
// 시간/분/초/밀리초 지정
today3.setHours(0, 0, 0, 0); // 00:00:00:00
 
console.log(today3); // Thu May 16 2019 00:00:00 GMT+0900 (한국 표준시)
console.log(today3.getHours()); // 0

const today4 = new Date();
 
// 분 지정
today4.setMinutes(50);
 
console.log(today4);   // Thu May 16 2019 17:50:30 GMT+0900 (한국 표준시)
console.log(today4.getMinutes()); // 50
 
// 분/초/밀리초 지정
today4.setMinutes(5, 10, 999); // HH:05:10:999
 
console.log(today4);   // Thu May 16 2019 17:05:10 GMT+0900 (한국 표준시)
console.log(today4.getMinutes()); // 5

const today5 = new Date();
 
// 초 지정
today5.setSeconds(30);
 
console.log(today5);   // Thu May 16 2019 17:54:30 GMT+0900 (한국 표준시)
console.log(today5.getSeconds()); // 30
 
// 초/밀리초 지정
today5.setSeconds(10, 0); // HH:MM:10:000
 
console.log(today5);   // Thu May 16 2019 17:54:10 GMT+0900 (한국 표준시)
console.log(today5.getSeconds()); // 10

const today6 = new Date();
 
// 밀리초 지정
today6.setMilliseconds(123);
 
console.log(today6); // Thu May 16 2019 17:55:45 GMT+0900 (한국 표준시)
console.log(today6.getMilliseconds());    // 123

const today7 = new Date(); // Fri Jan 01 1970 09:00:00 GMT+0900 (한국 표준시)
 
// 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초 지정
today7.setTime(86400000); // 86400000 === 1day
 
console.log(today7); // Fri Jan 02 1970 09:00:00 GMT+0900 (한국 표준시)
console.log(today7.getTime());  // 86400000

const today8 = new Date();
const x8 = today8.getTimezoneOffset() / 60; // 분단위값을 60으로 나눈다
 
console.log(today8); // Thu May 16 2019 17:58:13 GMT+0900 (한국 표준시)
console.log(x8);     // -9

const d9 = new Date('2019/5/16/18:30');
 
console.log(d9.toString());     // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)
console.log(d9.toDateString()); // Thu May 16 2019

const d10 = new Date('2019/5/16/18:30');
 
console.log(d10.toString());     // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)
console.log(d10.toTimeString()); // 18:30:00 GMT+0900 (한국 표준시)
```

```javascript
//현재 날짜와 시간을 초단위로 반복 출력하는 예시
(function printNow() {
  const today = new Date();
 
  const dayNames = ['(일)', '(월)', '(화)', '(수)', '(목)', '(금)', '(토)'];
  // getDay: 해당 요일(0 ~ 6)를 나타내는 정수를 반환한다.
  const day = dayNames[today.getDay()];
 
  const year = today.getFullYear();
  const month = today.getMonth() + 1;
  const date = today.getDate();
  let hour = today.getHours();
  let minute = today.getMinutes();
  let second = today.getSeconds();
 
  const ampm = hour >= 12 ? 'PM' : 'AM';
 
  // 12시간제로 변경
  hour %= 12;
  hour = hour || 12; // 12시,24시라서 나누어 떨어져서 0이면 12로 재설정 (12시간제)
 
  // 10미만인 분과 초를 2자리로 변경
  minute = minute < 10 ? '0' + minute : minute;
  second = second < 10 ? '0' + second : second;
 
  const now = `${year}년 ${month}월 ${date}일 ${day} ${hour}:${minute}:${second} ${ampm}`;
 
  console.log(now);
  setTimeout(printNow, 1000); // 1초마다 재귀처리
}());
```

```javascript
//날짜 계산 방법 - 현재, 어제, 내일, 한달 전, 한달 후
var today = new Date();	// 현재 날짜 및 시간
console.log("현재 : ", today);
 
var yesterday = new Date(today.setDate(today.getDate() - 1));	// 어제
console.log("어제 : ", yesterday);
 
var tomorrow = new Date(today.setDate(today.getDate() + 1));	// 내일
console.log("내일 : ", tomorrow);

var oneMonthAgo = new Date(today.setMonth(today.getMonth() - 1));	// 한달 전
console.log("한달 전 : ", oneMonthAgo);
 
var oneMonthLater = new Date(today.setMonth(today.getMonth() + 1));	// 한달 후
console.log("한달 후 : ", oneMonthLater);

var oneYearAgo = new Date(today.setYear(today.getFullYear() - 1));	// 1년 전
console.log("한달 전 : ", oneYearAgo);
 
var oneYearLater = new Date(today.setYear(today.getFullYear() + 1));	// 1년 후
console.log("한달 후 : ", oneYearLater);
```

#### Date 객체가 가지는 인자
| 인자 | 설명 |
|-----------------|----------------------------------------|
| year | 1900년 이후의 년 |
| month | 월을 나타내는 0 ~ 11까지의 정수 (주의: 0부터 시작, 0 = 1월) |
| day | 일을 나타내는 1 ~ 31까지의 정수 |
| hour | 시를 나타내는 0 ~ 23까지의 정수 |
| minute | 분을 나타내는 0 ~ 59까지의 정수 |
| second | 초를 나타내는 0 ~ 59까지의 정수 |
| millisecond | 밀리초를 나타내는 0 ~ 999까지의 정수 |

#### Date 관련 메소드
| 메소드 | 설명(값의 범위) |
|-----------------|----------------------------------------|
| getDate()	| 현지 시각으로 현재 일자에 해당하는 숫자를 반환(1 ~ 31) |
| getDay()	| 현지 시각으로 현재 요일에 해당하는 숫자를 반환(0 ~ 6) |
| getMonth() | 현지 시각으로 현재 월에 해당하는 숫자를 반환(0 ~ 11) |
| getFullYear()	| 현지 시각으로 현재 연도를 4비트의 숫자(YYYY)로 반환(YYYY) |
| getHours() | 현지 시각으로 현재 시각에 해당하는 숫자를 반환(0 ~ 23) |
| getMilliseconds()	| 현지 시각으로 현재 시각의 밀리초에 해당하는 숫자를 반환(0 ~ 999) |
| getMinutes() | 현지 시각으로 현재 시각의 분에 해당하는 숫자를 반환(0 ~ 59) |
| getSeconds() | 현지 시각으로 현재 시각의 초에 해당하는 숫자를 반환(0 ~ 59) |
| getTime()	| 1970년 1월 1일 0시 0분 0초부터 현재까지의 시간을 밀리초 단위로 환산한 값을 숫자로 반환 |
| getTimezoneOffset() | UTC로부터 현재 시각까지의 시간차를 분 단위로 환산한 값을 숫자로 반환 |
| setDate() | 현지 시각으로 특정 일자를 설정(1 ~ 31) |
| setMonth() | 현지 시각으로 특정 월을 설정(0 ~ 11) |
| setFullYear() | 현지 시각으로 특정 연도를 설정 (연도뿐만 아니라 월과 일자도 설정할 수 있음)	YYYY, MM, DD |
| setHours() | 현지 시각으로 특정 시간을 설정(0 ~ 23) |
| setMilliseconds() | 현지 시각으로 특정 밀리초를 설정함(0 ~ 999) |
| setMinutes() | 현지 시각으로 특정 분을 설정(0 ~ 59) |
| setSeconds() | 현지 시각으로 특정 초를 설정(0 ~ 59) |
| setTime() | 1970년 1월 1일 0시 0분 0초부터 밀리초 단위로 표현되는 특정 시간을 설정 |


### String 객체
```javascript
var str1 = 'Hello';
console.log(str1.length); // 글자수 -> 5

var str = 'Hello';
console.log(str.charAt(0)); // H
console.log(str.charAt(1)); // e
console.log(str.charAt(2)); // l
console.log(str.charAt(3)); // l
console.log(str.charAt(4)); // o
 
// 지정한 index가 범위(0 ~ str.length-1)를 벗어난 경우 빈문자열을 반환한다.
console.log(str.charAt(5)); // ''
 
// 문자열 순회. 문자열은 length 프로퍼티를 갖는다.
for (let i = 0; i < str.length; i++) {
  console.log(str.charAt(i));
}
 
// String 객체는 유사 배열 객체이므로 배열과 유사하게 접근할 수 있다.
for (let i = 0; i < str.length; i++) {
  console.log(str[i]); // str['0']
}

str = 'Hello World';
 
console.log(str.indexOf('l'));  // 2
console.log(str.indexOf('or')); // 7
console.log(str.indexOf('or' , 8)); // -1
 
if (str.indexOf('Hello') !== -1) {
  // 문자열 str에 'hello'가 포함되어 있는 경우에 처리할 내용
}
 
// ES6: String.prototype.includes
if (str.includes('Hello')) {
  // 문자열 str에 'hello'가 포함되어 있는 경우에 처리할 내용
}

console.log(str.lastIndexOf('World')); // 6
console.log(str.lastIndexOf('l'));     // 9
console.log(str.lastIndexOf('o', 5));  // 4
console.log(str.lastIndexOf('o', 8));  // 7
console.log(str.lastIndexOf('l', 10)); // 9
 
console.log(str.lastIndexOf('H', 0));  // 0
console.log(str.lastIndexOf('W', 5));  // -1
console.log(str.lastIndexOf('x', 8));  // -1

// 첫번째로 검색된 문자열만 대체하여 새로운 문자열을 반환한다.
str.replace('world', 'Kim'); // Hello Kim
 
// 특수한 교체 패턴을 사용할 수 있다. ($& => 검색된 문자열)
str.replace('world', '<strong>$&</strong>'); // Hello <strong>world</strong>
 
/* 정규표현식
g(Global): 문자열 내의 모든 패턴을 검색한다.
i(Ignore case): 대소문자를 구별하지 않고 검색한다.
*/
str.replace(/hello/gi, 'Kim'); // Kim world

var camelCase = 'helloWorld';
 
// 두번째 인수로 치환 함수를 전달할 수 있다.
// 특정 문자를 검색해 모두 대문자로 치환 하는 코드
// 문자를 찾아 인수로 match에 대입해 함수 실행
camelCase.replace("World", match => match.toUpperCase()); // "helloWORLD"
 
 
// /.[A-Z]/g => 1문자와 대문자의 조합을 문자열 전체에서 검색한다.
camelCase.replace(/.[A-Z]/g, function (match) {
  // match : oW => match[0] : o, match[1] : W
  return match[0] + '_' + match[1].toLowerCase();
}); // hello_world
 
 
// /(.)([A-Z])/g => 1문자와 대문자의 조합
// $1 => (.)
// $2 => ([A-Z])
camelCase.replace(/(.)([A-Z])/g, '$1_$2').toLowerCase(); // hello_world

var snake_case = 'hello_world';
 
// /_./g => _와 1문자의 조합을 문자열 전체에서 검색한다.
snake_case.replace(/_./g, function (match) {
  // match : _w => match[1] : w
  return match[1].toUpperCase();
}); // helloWorld

str.replace(' ','') // 첫번째 공백 제거
str.replace(/\-/g,'') // 특정문자 제거1 (-)
str.replace(/,/g,'') // 특정문자 제거2(,)
str.replace(/^\s+/,'') // 앞의 공백 제거
str.replace(/\s+$/,'') // 뒤의 공백 제거
str.replace(/^\s+|\s+$/g,'') // 앞뒤 공백 제거
str.replace(/\s/g,'') // 문자열 내의 모든 공백 제거
str.replace(/\n/g,'') // n개행 제거
str.replace(/\r/g,'') // 엔터 제거

str = 'How are you doing?';
 
// 공백으로 구분(단어로 구분)하여 배열로 반환한다
console.log(str.split(' ')); // [ 'How', 'are', 'you', 'doing?' ]
 
// 각 문자를 모두 분리한다
console.log(str.split('')); // [ 'H','o','w',' ','a','r','e',' ','y','o','u',' ','d','o','i','n','g','?' ]
 
// 정규 표현식
console.log(str.split(/\s/)); // [ 'How', 'are', 'you', 'doing?' ]
 
// 인수가 없는 경우, 대상 문자열 전체를 단일 요소로 하는 배열을 반환한다.
console.log(str.split()); // [ 'How are you doing?' ]
 
// 공백으로 구분하여 배열로 반환한다. 단 요소수는 3개까지만 허용한다
console.log(str.split(' ', 3)); // [ 'How', 'are', 'you' ]
 
// 'o'으로 구분하여 배열로 반환한다.
console.log(str.split('o')); // [ 'H', 'w are y', 'u d', 'ing?' ]

str = 'Hello World'; // str.length == 11
 
str.substring(1, 4); // ell
 
// 첫번째 인수 > 두번째 인수 : 순서 맞추기 위해 자동 교환된다.
str.substring(4, 1); // ell
 
// 두번째 인수가 생략된 경우 : 해당 문자열의 끝까지 반환한다.
str.substring(4); // o World
str.substring(4,); // o World
 
// 인수 < 0 또는 NaN인 경우 : 0으로 취급된다.
str.substring(-2); // Hello World
 
// 인수 > 문자열의 길이(str.length) : 인수는 문자열의 길이(str.length)으로 취급된다.
str.substring(1, 12); // ello World
str.substring(11); // '' str[10] == 'd'
str.substring(20); // ''
str.substring(0, str.indexOf(' ')); // 'Hello'
str.substring(str.indexOf(' ') + 1, str.length); // 'World'

str = 'hello world';
 
// 인수 < 0 또는 NaN인 경우 : 0으로 취급된다.
str.substring(-5); // 'hello world'
// 뒤에서 5자리를 잘라내어 반환한다.
str.slice(-5); // 'world'
 
// 2번째부터 마지막 문자까지 잘라내어 반환
tr.substring(2); // llo world
str.slice(2); // llo world
 
// 0번째부터 5번째 이전 문자까지 잘라내어 반환
str.substring(0, 5); // hello
str.slice(0, 5); // hello

str = '   foo  ';
 
console.log(str.trim()); // 'foo'
 
// String.prototype.replace
console.log(str.replace(/\s/g, ''));   // 'foo'
console.log(str.replace(/^\s+/g, '')); // 'foo  '
console.log(str.replace(/\s+$/g, '')); // '   foo'
 
// String.prototype.{trimStart,trimEnd} : Proposal stage 3
console.log(str.trimStart()); // 'foo  '
console.log(str.trimEnd());   // '   foo'

'abc'.repeat(0);   // ''
'abc'.repeat(1);   // 'abc'
'abc'.repeat(2);   // 'abcabc'
'abc'.repeat(2.5); // 'abcabc' (2.5 → 2)
'abc'.repeat(-1);  // RangeError: Invalid count value

str = 'hello world';
 
str.includes('hello'); // true
str.includes('hello', 0); // true
str.includes('hello', 2); // false
 
// String​.prototype​.indexOf 메소드로 대체할 수 있다.
str.indexOf('hello'); // 0

'abc'.padStart(10);         // "       abc"
'abc'.padStart(10, "foo");  // "foofoofabc"
'abc'.padStart(6,"123465"); // "123abc"
'abc'.padStart(8, "0");     // "00000abc"
'abc'.padStart(1);          // "abc"

'abc'.padEnd(10);          // "abc       "
'abc'.padEnd(10, "foo");   // "abcfoofoof"
'abc'.padEnd(6, "123456"); // "abc123"
'abc'.padEnd(1);           // "abc"
```

#### String 객체의 정규식 패턴
| $` | 문자 대체(replace) 시 일치한 문자 이전 값 참조 |
| $' | 문자 대체(replace) 시 일치한 문자 이후 값 참조 |
| $+ | 문자 대체(replace) 시 마지막으로 캡처된 값 참조 |
| $& | 문자 대체(replace) 시 일치한 문자 결과 전체 참조 |
| $_ | 문자 대체(replace) 시 입력(input)된 문자 전체 참조 |
| $1~9 | 문자 대체(replace) 시 캡처(Capture)된 값 참조 |

#### String 관련 메소드
| 메소드 | 설명 |
|-----------------|----------------------------------------|
| String.fromCharCode() | 쉼표로 구분되는 일련의 유니코드에 해당하는 문자들로 구성된 문자열을 반환 |
| String.fromCodePoint() | 쉼표로 구분되는 일련의 코드 포인트(code point)에 해당하는 문자들로 구성된 문자열을 반환 |
| String.raw() | 템플릿 문자열(template string)의 원형을 반환 |
| 인스턴스.indexOf(찾을값) | String 인스턴스에서 특정 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환 |
| 인스턴스.lastIndexOf(찾을값) | String 인스턴스에서 특정 문자나 문자열이 마지막으로 등장하는 위치의 인덱스를 반환 |
| 인스턴스.charAt(인덱스) | String 인스턴스에서 전달받은 인덱스에 위치한 문자를 반환함.
| 인스턴스.charCodeAt(인덱스) | String 인스턴스에서 전달받은 인덱스에 위치한 문자의 UTF-16 코드를 반환 (0 ~ 65535) |
| 인스턴스.charPointAt(인덱스) | String 인스턴스에서 전달받은 인덱스에 위치한 문자의 유니코드 코드 포인트(unicode code point)를 반환 |
| 인스턴스.slice(시작인덱스, 종료인덱스) | String 인스턴스에서 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 문자열을 추출한 새 문자열을 반환 |
| 인스턴스.substring(시작인덱스, 종료인덱스) | String 인스턴스에서 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 문자열을 추출한 새 문자열을 반환 |
| 인스턴스.substr(시작인덱스, 글자수) | String 인스턴스에서 전달받은 시작 인덱스부터 길이만큼의 문자열을 추출한 새로운 문자열을 반환 |
| 인스턴스.split("구분기호") | String 인스턴스에서 구분자(separator)를 기준으로 나눈 후, 나뉜 문자열을 하나의 배열로 반환 |
| 인스턴스.concat(결합한문자열) | String 인스턴스에 전달받은 문자열을 결합한 새로운 문자열을 반환 |
| 인스턴스.toUpperCase() | String 인스턴스의 모든 문자를 대문자로 변환한 새로운 문자열을 반환 |
| 인스턴스.toLowerCase() | String 인스턴스의 모든 문자를 소문자로 변환한 새로운 문자열을 반환 |
| 인스턴스.trim() | String 인스턴스의 양 끝에 존재하는 공백과 모든 줄 바꿈 문자(LF, CR 등)를 제거한 새로운 문자열을 반환 |
| 인스턴스.search(찾을값) | 인수로 전달받은 정규 표현식에 맞는 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환 |
| 인스턴스.replace(찾을값, 바꿀값) | 인수로 전달받은 패턴에 맞는 문자열을 대체 문자열로 변환한 새 문자열을 반환 |
| 인스턴스.match(찾을값) | 인수로 전달받은 정규 표현식에 맞는 문자열을 찾아서 하나의 배열로 반환 |
| 인스턴스.includes(찾을값) | 인수로 전달받은 문자나 문자열이 포함되어 있는지를 검사한 후 그 결과를 불리언 값으로 반환 |
| 인스턴스.startsWith(찾을값) | 인수로 전달받은 문자나 문자열로 시작되는지를 검사한 후 그 결과를 불리언 값으로 반환 |
| 인스턴스.endsWith(찾을값) | 인수로 전달받은 문자나 문자열로 끝나는지를 검사한 후 그 결과를 불리언 값으로 반환 |
| 인스턴스.toLocaleUpperCase() | 영문자뿐만 아니라 모든 언어의 문자를 대문자로 변환한 새로운 문자열을 반환 |
| 인스턴스.toLocaleLowerCase() | 영문자뿐만 아니라 모든 언어의 문자를 소문자로 변환한 새로운 문자열을 반환 |
| 인스턴스.localeCompare() | 인수로 전달받은 문자열과 정렬 순서로 비교하여 그 결과를 정수 값으로 반환 |
| 인스턴스.normalize() | 해당 문자열의 유니코드 표준화 양식(Unicode Normalization Form)을 반환 |
| 인스턴스.repeat(숫자) | 해당 문자열을 인수로 전달받은 횟수만큼 반복하여 결합한 새로운 문자열을 반환 |
| 인스턴스.toString("표시패턴 또는 숫자") | String 인스턴스의 값을 문자열로 반환 |
| 인스턴스.valueOf() | String 인스턴스의 값을 문자열로 반환 |


### Array 객체
```javascript
var arr = [
  'zero', 'one', 'two', 'three', 'four',
  'five', 'six', 'seven', 'eight', 'nine'
];

var arr = new Array(1, 2, 3);
 
var arr2 = new Array(20); // 인수 하나만 넘겨줄때는 그 인수가 배열길이
arr2.length // 20

arr1 = Array.from('Hello');
console.log(arr1); // [ 'H', 'e', 'l', 'l', 'o' ]
 
// 유사 배열 객체를 새로운 배열을 변환하여 반환한다.
arr2 = Array.from({ length: 2, 0: 'a', 1: 'b' });
console.log(arr2); // [ 'a', 'b' ]
 
// Array.from의 두번째 매개변수에게 배열의 모든 요소에 대해 호출할 함수를 전달할 수 있다.
// 이 함수는 첫번째 매개변수에게 전달된 인수로 생성된 배열의 모든 요소를 인수로 전달받아 호출된다.
var arr3 = Array.from({ length: 5 }, function (v, i) { return i; });
console.log(arr3); // [ 0, 1, 2, 3, 4 ]

arr1 = Array.of(1);
console.log(arr1); // // [1]
 
arr2 = Array.of(1, 2, 3);
console.log(arr2); // [1, 2, 3]
 
arr3 = Array.of('string');
console.log(arr3); // 'string'

// 리터럴 사용 방법
var zeroArray = [0, 0, 0, 0, 0, 0];
 
// fill()메소드 사용 방법
var zeroArray2 = Array(6).fill(0);
console.log(nullArray); // [0, 0, 0, 0, 0, 0]

[1, 2, 3].fill(4)                // [4, 4, 4] 모두 4로 채룸
[1, 2, 3].fill(4, 1)             // [1, 4, 4] 1번째 인덱스 부터 쭉 4로 채움
[1, 2, 3].fill(4, 1, 2)          // [1, 4, 3] 1번째에서 2번째 인덱스 전까지 4로 채움

// fill ()을 사용하여 모두 1의 행렬(2차원 배열) 만들기
var arr = new Array(3);
 
for (let i=0; i<arr.length; i++) {
  arr[i] = new Array(4).fill(1); // 크기가 4이고 1로 채워진 배열 생성
}
 
console.log(arr[0][0]); // 1
console.log(arr[1][0]); // 1
console.log(arr[2][0]); // 1

var foods = ['apple', 'banana', 'orange'];
 
// foods 배열에 'orange' 요소가 존재하는지 확인
if (foods.indexOf('orange') === -1) { // == if (!foods.includes('orange')) { } 
  foods.push('orange');
}
 
console.log(foods); // ["apple", "banana", "orange"]

var arr1 = [1, 2];
var arr2 = [3, 4];
 
// 배열 arr2를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환
// 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열의 요소로 추가한다.
let result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4]
 
// 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환
result = arr1.concat(3);
console.log(result); // [1, 2, 3]
 
//  배열 arr2와 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환
result = arr1.concat(arr2, 5);
console.log(result); // [1, 2, 3, 4, 5]
 
// 원본 배열은 변경되지 않는다.
console.log(arr1); // [1, 2]

var arr = [1, 2, 3, 4];
 
// 기본 구분자는 ','이다.
// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 기본 구분자 ','로 연결한 문자열을 반환
result = arr.join();
console.log(result); // '1,2,3,4';
 
// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 빈문자열로 연결한 문자열을 반환
result = arr.join('');
console.log(result); // '1234'
 
// 원본 배열 arr의 모든 요소를 문자열로 변환한 후, 구분자 ':'로 연결한 문자열을 반환
result = arr.join(':');
console.log(result); // '1:2:3:4'

arr1 = [1, 2];
// push 메소드는 원본 배열을 직접 변경한다.
arr1.push(3, 4);
console.log(arr1); // [1, 2, 3, 4]
 
var arr2 = [1, 2];
// concat 메소드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다.
result = arr2.concat(3, 4);
console.log(result); // [1, 2, 3, 4]

arr[arr.length] = 3;
console.log(arr); // [1, 2, 3]

// ES6 spread 문법
var newArr = [...arr, 3];
// arr.push(3);
 
console.log(newArr); // [1, 2, 3]

var a = ['a', 'b', 'c'];
var c = a.pop();
 
// 원본 배열이 변경된다.
console.log(a); // a --> ['a', 'b']
console.log(c); // c --> 'c'

var arr = [];
 
arr.push(1); // [1]
arr.push(2); // [1, 2]
arr.push(3); // [1, 2, 3]
 
arr.shift(); // [2, 3]
arr.shift(); // [3]
arr.shift(); // []

var items = ['a', 'b', 'c'];
 
// items[0]부터 items[1] 이전(items[1] 미포함)까지 반환
var res = items.slice(0, 1);
console.log(res);  // [ 'a' ]
 
// items[1]부터 items[2] 이전(items[2] 미포함)까지 반환
res = items.slice(1, 2);
console.log(res);  // [ 'b' ]
 
// items[1]부터 이후의 모든 요소 반환
res = items.slice(1);
console.log(res);  // [ 'b', 'c' ]
 
// 인자가 음수인 경우 배열의 끝에서 요소를 반환
res = items.slice(-1);
console.log(res);  // [ 'c' ]
 
res = items.slice(-2);
console.log(res);  // [ 'b', 'c' ]
 
// 모든 요소를 반환 (= 복사본(shallow copy) 생성)
res = items.slice();
console.log(res);  // [ 'a', 'b', 'c' ]

var todos = [
  { id: 1, content: 'HTML', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 3, content: 'Javascript', completed: false }
];
 
// shallow copy
var _todos = todos.slice();
// const _todos = [...todos];
console.log(_todos === todos); // false
 
// 배열의 요소는 같다. 즉, 얕은 복사
console.log(_todos[0] === todos[0]); // true

var sum = function() {
  // 유사 배열 객체 => Array
  const arr = Array.prototype.slice.call(arguments); // [1, 2, 3]
  const arr0 = [].slice.call(arguments); // [1, 2, 3]
  // Spread 문법
  const arr1 = [...arguments]; // [1, 2, 3]
  // Array.from 메소드는 유사 배열 객체를 복사하여 배열을 생성한다.
  const arr2 = Array.from(arguments); // [1, 2, 3]
}
 
console.log(sum(1, 2, 3));

var items1 = [1, 2, 3, 4];
 
// items[1]부터 2개의 요소를 제거하고 제거된 요소를 배열로 반환
var res1 = items1.splice(1, 2);
 
// 원본 배열이 변경된다.
console.log(items1); // [ 1, 4 ]
// 제거한 요소가 배열로 반환된다.
console.log(res1);   // [ 2, 3 ]
 
// -------------------------------------------
 
const items2 = [1, 2, 3, 4];
 
// items[1]부터 모든 요소를 제거하고 제거된 요소를 배열로 반환
const res2 = items2.splice(1);
 
// 원본 배열이 변경된다.
console.log(items2); // [ 1 ]
// 제거한 요소가 배열로 반환된다.
console.log(res2);   // [ 2, 3, 4 ]

var items = [1, 2, 3, 4];
 
// items[1]부터 2개의 요소를 제거하고 그자리에 새로운 요소를 추가한다. 제거된 요소가 반환된다.
var res = items.splice(1, 2, 20, 30);
 
// 원본 배열이 변경된다.
console.log(items); // [ 1, 20, 30, 4 ]
// 제거한 요소가 배열로 반환된다.
console.log(res);   // [ 2, 3 ]

var items = [1, 2, 3, 4];
 
// items[1]부터 0개의 요소를 제거하고 그자리(items[1])에 새로운 요소를 추가한다. 제거된 요소가 반환된다.
var res = items.splice(1, 0, 100);
 
// 원본 배열이 변경된다.
console.log(items); // [ 1, 100, 2, 3, 4 ]
// 제거한 요소가 배열로 반환된다.
console.log(res);   // [ ]

var items = [1, 4];
var items2 = [2, 3];
 
// 원본배열 item를 아규먼트 인자로 items2를 받아서,
// items[1]부터 0개의 요소를 제거하고 그자리(items[1])에 새로운 배열를 추가한다. 
 
// 이렇게 하면 아규먼트가 2차원형태가 되어버린다. ( 1, [ 2, 3 ], 4 )
items.splice(1, 0, items2);
 
// apply로 items를 주고, [1, 0].concat([2, 3])의 결과 인자 1,0, 2,3을 주게되는 꼴이 된다.
Array.prototype.splice.apply(items, [1, 0].concat([2, 3]));
 
items.splice(1,0, 2,3)
// == [].splice.apply(items, [1, 0].concat([2, 3]));
// == items.splice(1, 0, ...items);
 
console.log(items); // [ 1, 2, 3, 4 ]
```

#### Array 관련 메소드
| 메소드 | 설명 |
|-----------------|----------------------------------------|
| Array.isArray() | 전달된 값이 Array 객체인지 아닌지를 검사 |
| Array.from() | 배열과 비슷한 객체와 반복할 수 있는 객체를 배열처럼 변환 |
| Array.of() | 인수의 수나 타입에 상관없이 인수로 전달받은 값을 가지고 새로운 Array 인스턴스를 생성 |
| 인스턴스명.push() | 하나 이상의 요소를 배열의 가장 마지막에 추가하고, 배열의 총 길이를 반환 |
| 인스턴스명.pop() | 배열의 가장 마지막 요소를 제거하고, 그 제거된 요소를 반환 |
| 인스턴스명.shift() | 배열의 가장 첫 요소를 제거하고, 그 제거된 요소를 반환 |
| 인스턴스명.unshift() | 하나 이상의 요소를 배열의 가장 앞에 추가하고, 배열의 총 길이를 반환 |
| 인스턴스명.reverse() | 배열 요소의 순서를 전부 반대로 교체 |
| 인스턴스명.sort() | 해당 배열의 배열 요소들을 알파벳 순서에 따라 정렬 |
| 인스턴스명.splice() | 기존의 배열 요소를 제거하거나 새로운 배열 요소를 추가하여 배열의 내용을 변경 |
| 인스턴스명.copyWithin() | 해당 배열에서 일련의 요소들을 복사하여, 명시된 위치의 요소들을 교체 |
| 인스턴스명.fill() | 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 특정 값으로 교체 |
| 인스턴스명.join() | 배열의 모든 요소를 하나의 문자열로 반환 |
| 인스턴스명.slice() | 전달받은 시작 인덱스부터 종료 인덱스 바로 앞까지의 모든 배열 요소를 추출하여 만든 새로운 배열을 반환 |
| 인스턴스명.concat() | 해당 배열의 뒤에 인수로 전달받은 배열을 합쳐서 만든 새로운 배열을 반환 |
| 인스턴스명.toString() | 해당 배열의 모든 요소를 하나의 문자열로 반환 |
| 인스턴스명.toLocaleString() | 해당 배열의 모든 요소를 하나의 문자열로 반환 |
| 인스턴스명.indexOf() | 전달받은 값과 동일한 배열 요소가 처음으로 등장하는 위치의 인덱스를 반환 |
| 인스턴스명.lastIndexOf() | 전달받은 값과 동일한 배열 요소가 마지막으로 등장하는 위치의 인덱스를 반환 |
| 인스턴스명.forEach() | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행 |
| 인스턴스명.map() | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행한 후, 그 실행 결과를 새로운 배열로 반환 |
| 인스턴스명.filter() | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행한 후, 그 결괏값이 true인 요소들만을 새로운 배열에 담아 반환 |
| 인스턴스명.every() | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행한 후, 그 결괏값이 모두 true일 때에만 true를 반환 |
| 인스턴스명.some() | 해당 배열의 모든 요소에 대하여 반복적으로 명시된 콜백 함수를 실행한 후, 그 결괏값이 하나라도 true이면 true를 반환 |
| 인스턴스명.reduce() | 해당 배열의 모든 요소를 하나의 값으로 줄이기 위해, 두 개의 인수를 전달받는 콜백 함수를 실행 |
| 인스턴스명.reduceRight() | 해당 배열의 모든 요소를 하나의 값으로 줄이기 위해, 두 개의 인수를 전달받는 콜백 함수를 실행 |
| 인스턴스명.entries() | 배열 요소별로 키와 값의 한 쌍으로 이루어진 새로운 배열 반복자 객체(Array Iterator Object)를 배열 형태로 반환 |
| 인스턴스명.keys() | 배열 요소별로 키(key)만 포함하는 새로운 배열 반복자 객체를 배열 형태로 반환 |
| 인스턴스명.values() | 배열 요소별로 값(value)만 포함하는 새로운 배열 반복자 객체를 배열 형태로 반환 |
| 인스턴스명.find() | 검사를 위해 전달받은 함수를 만족하는 배열 요소의 값을 반환함. 만족하는 값이 없으면 undefined를 반환 |
| 인스턴스명.findIndex() | 검사를 위해 전달받은 함수를 만족하는 배열 요소의 인덱스를 반환함. 만족하는 값이 없으면 -1을 반환 |

### 기타 객체

#### 타이머 객체
    - setTimeout : 주어진 시간이 지나면 한 번만 실행하게 됨
    - setInterval : 정해진 시간을 주기로 계속 실행하게 됨
```javascript
//setTimeout
//기본 사용
var sayHi = function() {
  alert('안녕하세요.');
}
setTimeout(function() { sayHi(); }, 1000);

//매개변수 활용
function sayHi2(who, phrase) {
  alert( who + ' 님, ' + phrase );
}
setTimeout(function() { sayHi2(); }, 1000, "홍길동", "안녕하세요."); // 홍길동 님, 안녕하세요.

//익명의 함수(람다식 활용)
setTimeout(() => alert('안녕하세요.'), 1000);

//타임아웃 취소하기
var timerId = setTimeout(() => alert('안녕하세요.'), 1000);
clearTimeout(timerId);

//setInterval
// 2초 간격으로 메시지를 보여줌
let timerId = setInterval(() => alert('째깍'), 2000);
 
// 5초 후에 정지
setTimeout(() => { 
	clearInterval(timerId); 
	alert('정지'); 
}, 5000);
```

---------------------------------------------------------------

## BOM(Browser Object Model) 객체

### Window 객체
    브라우저 창 객체, BOM의 최상위 객체

```html
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>window객체</title>
        <style>
            body{ height: 3000px; } /* 세로스크롤바 생성 */
        </style>
        <script>
            //창사이즈 확인 속성
            //1. innerWidth : 창의 가로폭(스크롤바제외)
            //2. outerWidth : 창의 가로폭(모두포함)
            //3. innerHeight : 창의 높이(스크롤바제외)
            //4. outerHeight : 창의 높이(모두포함)

            document.write('innerWidth : ' + window.innerWidth + '<br>');
            document.write('outerWidth : ' + window.outerWidth);
            for(var key in window){     //window 객체가 가지는 속성, 하위 객체, 메소드를 출력
                document.write("<br>"+key+" : "+window[key]);
            }
        </script>
    </head>
    <body>
        
    </body>
</html>
```

#### window 객체의 속성
| 속성 | 설명 |
|-----------|----------------------------------------------|
| closed | 창이 닫혀 있는지 열려 있는지를 불표현식으로 반환 닫혀 있으면 true반환, 열려 있으면 false반환 |
| innerHeight | 창의 콘텐츠 영역 높이를 반환 - 스크롤바나 제목표시줄 등은 제외 |
| innerWidth | 창의 콘텐츠 영역 폭을 반환 - - 스크롤바나 제목표시줄 등은 제외 |
| length | 현재 창의 아이프레임 개수를 숫자로 반환 |
| outerHeight | 창의 모든 인터페이스요소(스크롤바등)을 포함한 높이를 반환 |
| outerWidth | 창의 모든 인터페이스요소(스크롤바등)을 포함한 높이를 반환 |
| pageXOffset | 현재 문서가 창의 왼쪽에서 얼마나 스크롤되어 있는지를 픽셀수치로 반환 |
| pageYOffset | 현재 문서가 창의 위쪽에서 얼마나 스크롤되어 있는지를 픽셀수치로 반환 |
| parent | 아이프레임으로 되어 있는 페이지의 부모가되는 페이지를 선택하는 속성 |
| screenLeft | 창이 화면 좌측을 기준으로 얼마큼 떨어져 있는지 좌표를 반환 |
| screenTop | 창이 화면 상단을 기준으로 얼마큼 떨어져 있는지 좌표를 반환 |
| screenX | 창이 화면 좌측을 기준으로 얼마큼 떨어져 있는지 좌표를 반환 |
| screenY | 창이 화면 상단을 기준으로 얼마큼 떨어져 있는지 좌표를 반환 |
| self | 현재 창을 반환 |
| top | 현재 창의 최상위 브라우저 창을 반환 |


#### window 객체의 관련 메소드
| 메서드 | 설명 |
|-----------|----------------------------------------------|
| close() | 창을 닫는 메서드 - 매개변수는 없음 |
| moveBy(x,y) | 창을 상대적으로 이동시키는 메서드 |
| moveTo(x,y) | 창을 절대적으로 이동시키는 메서드 |
| open(url,name,specs,replace) | 새창 혹은 새탭으로 창을 여는 메서드 |
| print() | 현재 창을 인쇄할수 있는 창을 띄워주는 메서드 |
| resizeBy(w,h) | 창 사이즈를 상대적으로 변경시키는 메서드 |
| resizeTo(w,h) | 창 사이즈를 절대적으로 변경시키는 메서드 |
| scrollBy(x,y) | 창의 스크롤바 위치를 상대적으로 이동시키는 메서드 |
| scrollTo(x,y) | 창의 스크롤바 위치를 절대적으로 이동시키는 메서드 |
| stop() | 창이 로드되는 것을 멈추는 메서드 - ie 및 edge는 사용 불가능 |

#### window 객체의 open 메소드의 매개변수
| 매개변수 | 설명 |
|-----------|----------------------------------------------|
| URL | 창으로 띄울 주소를 담는 매개변수 |
|-----------|----------------------------------------------|
| name | 창이 띄워질 위치(대상)을 지정하는 매개변수 |
|    | _blank : url의 주소가 새창 혹은 새탭으로 띄워짐 - 기본값 |
|    | _parent : 아이프레임의 부모가 되는 페이지로 url주소가 띄워짐 |
|    | _self : 현재 페이지로 url주소가 띄워짐 => 주소가 바뀜 |
|    | _top : 로딩되는 모든 frameset으로 url주소가 띄워짐 |
|    | name : 새창으로 띄워진 곳의 이름을 작성하면 그곳에서 url주소가 띄워짐 |
|-----------|----------------------------------------------|
| specs	| 띄워지는 창에 대한 옵션을 설정, 쉼표로 아이템을 구분해서 작성 |
|    | window.open('주소'.'_blank','옵션=값,옵션=값',true); |
|    | specs 값 | 
|    | (대부분의 값은 yes|no|1|0으로 지정하면 된다.) (위치나 크기는 수치만 적고 픽셀단위로 인정된다) |
| channelmode | 극장 모드로 띄울지를 지정하는 옵션, IE만 가능 |
| directories | 디렉토리 버튼 추가 여부, IE만 가능하고 구버전들에게만 있음 |
| fullscreen | 풀스크린모드로 띄울지를 지정하는 옵션, IE만 가능 |
| height | 창의 높이를 지정하는 옵션, 최소값은 100으로 처리 |
| left | 창의 왼쪽 좌표를 지정하는 옵션, 음수는 지정되지 않음 |
| location | 주소표시줄을 표시할지 지정하는 옵션, 오페라브라우저에만 사용가능 |
| menubar | 메뉴바를 표시할지 지정하는 옵션 |
| resizable | 창사이즈를 변경하지 지정하는 옵션, IE만 가능 |
| scrollbars | 스크롤바를 표시할지 지정하는 옵션, 다만, 로딩되는 페이지의 스타일이나 스크립트가 우선한다. |
| status | 상태표시줄을 표시할지 지정하는 옵션 |
| titlebar | 타이틀바를 표시할지 지정하는 옵션 |
| toolbar | 브라우저 툴바를 표시할지 지정하는 옵션, IE와 Firefox만 가능 |
| top | 창의 상단 좌표를 지정하는 옵션, 음수는 지정되지 않음 |
| width | 창의 가로폭을 지정하는 옵션, 최소사이즈는 100으로 처리 |
|-----------|----------------------------------------------|
| replace | url로 작성한 주소를 새항목으로 만들지, history 목록의 현재 항목으로 대체할지를 지정 |
|   | - true : history목록의 현재 문서로 대체 |
|   | - false : 주소를 새 항목으로 대체 |
|-----------|----------------------------------------------|


### Screen 객체
    운영체제의 바탕 화면 객체
```html
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>screen 객체</title>
        <style>
            body{ height: 3000px; } /* 세로스크롤바 생성 */
        </style>
        <script>
        for(var key in screen){     //screen 객체가 가지는 속성, 하위 객체, 메소드를 출력
                document.write("<br>"+key+" : "+screen[key]);
        }
        </script>
    </head>
    <body>
        
    </body>
</html>
```

#### Screen 객체의 속성 
| 속성 | 설명 |
|-----------|----------------------------------------------|
| width | 화면의 너비를 반환 |
| height | 화면의 높이를 반환 |
| availWidth | 화면에서 작업표시줄을 제외한 너비를 반환 |
| availHeigth | 화면에서 작업표시줄을 제외한 높이를 반환 |
| colorDepth | 화면에서 사용 가능한 색상 수를 반환 |
| pixelDepth | 화면의 색상 해상도를 반환 |


### Location 객체
    주소표시줄(URL) 객체
```html
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>location 객체</title>
        <style>
            body{ height: 3000px; } /* 세로스크롤바 생성 */
        </style>
        <script>
        for(var key in location){     //location 객체가 가지는 속성, 하위 객체, 메소드를 출력
                document.write("<br>"+key+" : "+location[key]);
        }
        </script>
    </head>
    <body>
        
    </body>
</html>
```

#### Location 객체의 속성
| 속성 | 설명 |
|-----------|----------------------------------------------|
| hash | hash속성은 url의 해시기호(#)를 포함하여 주소를 설정하거나 반환하는 속성 |
| host | host속성은 url의 호스트명과 포트를 설정하거나 반환하는 속성 |
| hostname | hostname속성은 url의 호스트명을 설정하거나 반환하는 속성 |
| href | href속성은 현재 페이지의 전체 url를 설정하거나 반환하는 속성 |
| origin | origin속성은 url의 프로토콜, 호스트명, 포트번호를 반환하는 속성 |
| pathname | pathname속성은 url의 경로이름을 설정하거나 반환하는 속성 |
| port | port속성은 서버가 url에 사용하는 포트번호를 설정하거나 반환하는 속성 |
| protocol | protocol속성은 콜론을 포함하여 현재 url의 프로토콜을 설정하거나 반환하는 속성 |
| search | search속성은 ?(물음표)를 포함하여 url의 쿼리 문자열을 설정하거나 반환하는 속성 |


#### Location 객체의 관련 메소드
| 메서드 | 설명 |
|-----------|----------------------------------------------|
| assign(url) | 주소표시줄의 주소를 매개변수의 url주소로 변경하는 메서드 현재 문서 기록에서 url이 남아 [뒤로가기]버튼을 사용하여 원래 페이지로 돌아갈수 있습니다.  최근 크롬에서는 안되는 이슈가 있습니다. |
| replace(url) | 주소표시줄의 주소를 매개변수의 url주소로 변경하는 메서드 현재 문서 기록에서 url을 제거하여 [뒤로가기]버튼을 눌러 원래 페이지로 돌아갈수 없습니다. |
| reload() | 주소표시줄을 새로고침하는 메서드 |

### History 객체
    방문했던 정보를 기록하고 있는 객체
```html
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>history 객체</title>
        <style>
            body{ height: 3000px; } /* 세로스크롤바 생성 */
        </style>
        <script>
        for(var key in history){     //history 객체가 가지는 속성, 하위 객체, 메소드를 출력
                document.write("<br>"+key+" : "+history[key]);
        }
        </script>
    </head>
    <body>
        
    </body>
</html>
```

#### History 객체의 속성과 메소드
| 속성 또는 메소드 | 설명 |
|-----------|----------------------------------------------|
| length | 현재 브라우저 창의 기록 목록에 있는 URL 수를 반환하는 속성 |
| back() | 현재 브라우저 창의 기록 목록 중 이전목록으로 보내는 메서드 |
| forward() | 현재 브라우저 창의 기록 목록 중 다음목록으로 보내는 메서드 |
| go(n) | 현재 브라우저 창의 기록 목록에서 매개변수 숫자를 이용하여 그 목록으로 보내는 메서드. 음수는 이전으로 보내고, 양수를 작성하면 다음으로 처리 |


### Navigator 객체
    브라우저 객체
```html
<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <title>navigator 객체</title>
        <style>
            body{ height: 3000px; } /* 세로스크롤바 생성 */
        </style>
        <script>
        for(var key in navigator){     //navigator 객체가 가지는 속성, 하위 객체, 메소드를 출력
                document.write("<br>"+key+" : "+navigator[key]);
        }
        </script>
    </head>
    <body>
        
    </body>
</html>
```

#### Navigater 객체의 속성과 메소드
| 속성 또는 메소드 | 설명 |
|-----------|----------------------------------------------|
| appCodeName | 브라우저의 코드명을 반환. 모든 최신 브라우저는 호환성을 이유로 [Mozilla]를 반환하는 속성 |
| appName | 브라우저의 이름을 반환. IE11, Firefox, Chrome, Safari는 [Netscape]를 반환. IE10이하의 버전은 [Microsoft Internet Explorer]를 반환. Opera는 [Opera]를 반환 속성 |
| appVersion | 브라우저의 버전 정보를 반환 속성 |
| cookieEnabled | 브라우저에서 쿠키를 사용할지 여부를 지정하는 불표현식(true/false)를 반환 속성 |
| geolocation | 사용자의 위치를 찾는데 사용할 수 있는 Geolocation개체를 반환 속성 |
| language | 브라우저의 언어버전을 반환 속성 |
| onLine | 브라우저가 온라인 또는 오프라인 모드인지 불표현식(true/false)를 반환 속성 |
| platform | 브라우저가 컴파일되는 플랫폼을 반환 속성 |
| product | 브라우저의 엔진 이름을 반환. 모든 브라우저가 [Gecko]라고 반환 속성 |
| userAgent | 브라우저에서 서버로 보낸 사용자 에이전트 헤더의 값을 반환 속성 |
| javaEnabled()	브라우저에서 javascript를 사용할 수 있는지 불표현식(true/false)로 반환하는 메소드 |


## DOM(Document Object Model) 객체

### Document Element
```javascript
//태그 선택
var selectedItem = document.getElementsByTagName("li"); // 모든 <li> 요소를 선택함.
for (var i = 0; i < selectedItem.length; i++) {
    selectedItem.item(i).style.color = "red"; // 선택된 모든 요소의 텍스트 색상을 변경함.
}

//아이디 선택
var selectedItem = document.getElementById("even"); // 아이디가 "even"인 요소를 선택함.
selectedItem.style.color = "red"; // 선택된 요소의 텍스트 색상을 변경함.

//클래스 선택
var selectedItem = document.getElementsByClassName("odd"); // 클래스가 "odd"인 모든 요소를 선택함.
for (var i = 0; i < selectedItem.length; i++) {
    selectedItem.item(i).style.color = "red"; // 선택된 모든 요소의 텍스트 색상을 변경함.
}

//name 속성을 활용한 선택
var selectedItem = document.getElementsByName("first"); // name 속성값이 "first"인 모든 요소를 선택함.
for (var i = 0; i < selectedItem.length; i++) {
    selectedItem.item(i).style.color = "red"; // 선택된 모든 요소의 텍스트 색상을 변경함.
}

//css 선택자를 이용한 선택
var selectedItem = document.querySelectorAll("li.odd"); // 클래스가 "odd"인 요소 중에서 <li> 요소만을 선택함.
for (var i = 0; i < selectedItem.length; i++) {
    selectedItem.item(i).style.color = "red"; // 선택된 모든 요소의 텍스트 색상을 변경함.
}

var title = document.title; // <title> 요소를 선택함.
document.write(title);

var str = document.getElementById("text");
str.innerHTML = "이 문장으로 바뀌었습니다!";

var link = document.getElementById("link");          // 아이디가 "link"인 요소를 선택함.
link.href = "/javascript/intro"; // 해당 요소의 href 속성값을 변경함.
link.innerHTML = "자바스크립트 수업 바로 가기!";     // 해당 요소의 내용을 변경함.

var str = document.getElementById("text");                 // 아이디가 "text"인 요소를 선택함.
function changeRedColor() { str.style.color = "red"; }     // 해당 요소의 글자색을 빨간색으로 변경함.
function changeBlackColor() { str.style.color = "black"; } // 해당 요소의 글자색을 검정색으로 변경함.

// HTML 문서의 모든 자식 노드 중에서 두 번째 노드의 이름을 선택함.
document.getElementById("document").innerHTML = document.childNodes[1].nodeName;           // HTML

// html 노드의 모든 자식 노드 중에서 첫 번째 노드의 이름을 선택함.
document.getElementById("html").innerHTML = document.childNodes[1].childNodes[0].nodeName; // HEAD

// 아이디가 "heading"인 요소의 첫 번째 자식 노드의 노드값을 선택함.
var headingText = document.getElementById("heading").firstChild.nodeValue;
document.getElementById("text1").innerHTML = headingText;
document.getElementById("text1").firstChild.nodeValue = headingText;

// 아이디가 "heading"인 요소의 첫 번째 자식 노드의 타입을 선택함.
var headingType = document.getElementById("heading").firstChild.nodeType;
document.getElementById("head").innerHTML = headingType;           // 3
document.getElementById("document").innerHTML = document.nodeType; // 9

// 아이디가 "list"인 요소의 모든 자식 노드들을 선택함.
var listItems = document.getElementById("list").childNodes;

// 자식 노드들 중 첫 번째 li 요소의 내용을 변경함.
listItems[1].firstChild.nodeValue = "HTML 요소의 내용을 변경했어요!";

// 아이디가 "list"인 요소의 모든 자식 노드들을 선택함.
var listItems = document.getElementById("list").childNodes;

// 자식 노드들 중 첫 번째 노드의 값을 출력함.
document.write(listItems[0].nodeValue + "<br>");

// 자식 노드들 중 두 번째 노드의 자식 노드 중 첫 번째 노드의 값을 출력함.
document.write(listItems[1].firstChild.nodeValue + "<br>");

// 자식 노드들 중 세 번째 노드의 값을 출력함.
document.write(listItems[2].nodeValue);

var listItems = document.getElementsByTagName("li");              // 모든 <li> 요소들을 선택함.
document.getElementById("text").innerHTML = "이 노드 리스트의 길이는 " + listItems.length + "개 입니다.<br>"; // 모든 자식 노드들의 개수를 반환함.
function changeTextColor() {
    for (var i = 0; i < listItems.length; i++) {
        listItems[i].style.color = "orange";                      // 모든 자식 노드들의 글자색을 변경함.
    }
}


//자식 노드 추가
function appendNode() {
    var parent = document.getElementById("list");  // 아이디가 "list"인 요소를 선택함.
    var newItem = document.getElementById("item"); // 아이디가 "item"인 요소를 선택함.
    parent.appendChild(newItem);                   // 해당 요소의 맨 마지막 자식 노드로 추가함.
}

function appendNode2() {
    var parent = document.getElementById("list");           // 아이디가 "list"인 요소를 선택함.
    var criteriaItem = document.getElementById("criteria"); // 아이디가 "criteria"인 요소를 선택함.
    var newItem = document.getElementById("item");          // 아이디가 "item"인 요소를 선택함.
    parent.insertBefore(newItem, criteriaItem); // 해당 노드를 기준이 되는 자식 노드의 바로 앞에 추가함.
}

var text = document.getElementById("text").firstChild; // 아이디가 "text"인 요소의 텍스트 노드를 선택함.
function appendText() {
    text.insertData(6, " 나른한 "); // 텍스트 노드의 6번째 문자부터 " 나른한 "이란 텍스트를 추가함.
}

//요소의 생성
function createNode() {
    var criteriaNode = document.getElementById("text"); // 기준이 되는 요소로 아이디가 "text"인 요소를 선택함.
    var newNode = document.createElement("p");          // 새로운 <p> 요소를 생성함.
    newNode.innerHTML = "새로운 단락입니다.";
    document.body.insertBefore(newNode, criteriaNode);  // 새로운 요소를 기준이 되는 요소 바로 앞에 추가함.
}

function createAttrNode() {
    var text = document.getElementById("text");           // 아이디가 "text"인 요소를 선택함.
    var newAttribute = document.createAttribute("style"); // 새로운 style 속성 노드를 생성함.
    newAttribute.value = "color:red";
    text.setAttributeNode(newAttribute);                  // 해당 요소의 속성 노드로 추가함.
}

function createTextNode() {
    var elementNode = document.getElementById("text");           // 아이디가 "text"인 요소를 선택함.
    var newText = document.createTextNode("새로운 텍스트에요!"); // 새로운 텍스트 노드를 생성함.
    elementNode.appendChild(newText);                            // 해당 요소의 자식 노드로 추가함.
}

var parent = document.getElementById("list");      // 아이디가 "list"인 요소를 선택함.
var removedItem = document.getElementById("item"); // 아이디가 "item"인 요소를 선택함.
parent.removeChild(removedItem);                   // 지정된 요소를 삭제함.

var text = document.getElementById("text"); // 아이디가 "text"인 요소를 선택함.
text.removeAttribute("style");              // 해당 요소의 "style" 속성을 제거함.

//요소 복제
function cloneElement() {
    var parent = document.getElementById("list");     // 아이디가 "list"인 요소를 선택함.
    var originItem = document.getElementById("item"); // 아이디가 "item"인 요소를 선택함.
    parent.appendChild(originItem.cloneNode(true));   // 해당 노드를 복제하여 리스트의 맨 마지막에 추가함.
}

//요소의 값 조작
var para = document.getElementById("text"); // 아이디가 "text"인 요소를 선택함.
function changeText() {
    para.firstChild.nodeValue = "텍스트 변경 완료!";
}

var para;

function changeAttribute() {
    // 모든 <p> 요소중에서 첫 번째 요소에 클래스 속성값으로 "para"를 설정함.
    document.getElementsByTagName("p")[0].setAttribute("class", "para");
    // 클래스가 설정되면 해당 클래스에 설정되어 있던 스타일이 자동으로 적용됨.
}

var parent = document.getElementById("parent"); // 부모 노드를 선택함.
var first = document.getElementById("first");
var third = document.getElementById("third");
function changeNode() {
    parent.replaceChild(third, first);          // first 요소를 삭제하고, 그 대신 third 요소를 삽입함.
}

var text = document.getElementById("text").firstChild; // 아이디가 "text"인 요소의 텍스트 노드를 선택함.
function changeText() {
    text.replaceData(7, 4, "저녁 7"); // 텍스트 노드의 7번째 문자부터 4개의 문자를 "저녁 7"로 교체함.
}
```

#### DOM 요소의 메소드 종류
| 메소드 | 설명 |
|-----------|----------------------------------------------|
| document.getElementsByTagName(태그이름) | 해당 태그 이름의 요소를 모두 선택 |
| document.getElementById(아이디) | 해당 아이디의 요소를 선택 |
| document.getElementsByClassName(클래스이름) | 해당 클래스에 속한 요소를 모두 선택 |
| document.getElementsByName(name속성값) | 해당 name 속성값을 가지는 요소를 모두 선택 |
| document.querySelectorAll(선택자) | 해당 선택자로 선택되는 요소를 모두 선택 |
| document.createElement(HTML요소) | 지정된 HTML 요소를 생성 |
| document.write(텍스트) | HTML 출력 스트림을 통해 텍스트를 출력 |


#### DOM 요소의 객체 집합
| 객체 집합 | 설명 |
|-----------|----------------------------------------------|
| document.anchors | name 속성을 가지는 <a>요소를 모두 반환 |
| document.applets | applet 요소를 모두 반환함. (HTML5에서 제외됨) |
| document.body | <body>요소를 반환 |
| document.cookie | HTML 문서의 쿠키(cookie)를 반환 |
| document.domain | HTML 문서가 위치한 서버의 도메인 네임(domain name)을 반환 |
| document.forms | <form>요소를 모두 반환 |
| document.images | <img>요소를 모두 반환 |
| document.links | href 속성을 가지는 <area>요소와 <a>요소를 모두 반환 |
| document.referrer | 링크(linking)되어 있는 문서의 URI를 반환 |
| document.title | <title>요소를 반환 |
| document.URL | HTML 문서의 완전한 URL 주소를 반환 |
| document.baseURI | HTML 문서의 절대 URI(absolute base URI)를 반환 |
| document.doctype | HTML 문서의 문서 타입(doctype)을 반환 |
| document.documentElement | <html>요소를 반환 |
| document.documentMode | 웹 브라우저가 사용하고 있는 모드를 반환 |
| document.documentURI | HTML 문서의 URI를 반환 |
| document.domConfig | HTML DOM 설정을 반환 (더는 사용하지 않음) | 
| document.embeds | <embed>요소를 모두 반환 |
| document.head | <head>요소를 반환 |
| document.implementation | HTML DOM 구현(implementation)을 반환 |
| document.inputEncoding | HTML 문서의 문자 인코딩(character set) 형식을 반환 |
| document.lastModified | HTML 문서의 마지막 갱신 날짜 및 시간을 반환 |
| document.readyState HTML | 문서의 로딩 상태(loading status)를 반환 |
| document.scripts | <script>요소를 모두 반환 |
| document.strictErrorChecking | 오류의 강제 검사 여부를 반환 |


#### DOM 요소의 노드
| 노드 | 설명 |
|-----------|----------------------------------------------|
| 문서 노드(document node) | HTML 문서 전체를 나타내는 노드 |
| 요소 노드(element node) | 모든 HTML 요소는 요소 노드이며, 속성 노드를 가질 수 있는 유일한 노드 |
| 속성 노드(attribute node) | 모든 HTML 요소의 속성은 속성 노드이며, 요소 노드에 관한 정보를 가지고 있음. 하지만 해당 요소 노드의 자식 노드(child node)에는 포함되지 않음. |
| 텍스트 노드(text node) | HTML 문서의 모든 텍스트는 텍스트 노드 | 
| 주석 노드(comment node) | HTML 문서의 모든 주석은 주석 노드 |